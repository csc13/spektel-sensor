<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>XMEGA, ASF and TWI/I2C &#8211; spektel-sensor</title>
<meta name="description" content="Getting TWI and I2C running with the Atmel ASF and XMEGA">
<meta name="keywords" content="Atmel, AVR, microcontroller, XMEGA, TWI, I2C, XMEGA32E5">


<meta property="og:locale" content="en_US">
<meta property="og:title" content="XMEGA, ASF and TWI/I2C &#8211; spektel-sensor">
<meta property="og:description" content="Getting TWI and I2C running with the Atmel ASF and XMEGA">
<meta property="og:url" content="/articles/XMEGA_ASF_TWI">
<meta property="og:site_name" content="spektel-sensor">


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="spektel-sensor Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Type -->
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic" rel='stylesheet' type='text/css' />
<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/css/entypo.css" media="all">

<!-- In order to use Calendas Plus, you must first purchase it. Then, create a font-face package using FontSquirrel.
<link rel='stylesheet' href='/assets/cal.css' media='all' />
-->



<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/i.css">

<!-- Fresh Squeezed jQuery -->

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">

<div id="bump">
  <body class="">
    <header class="site-header">
      <div class="wrap">
        <hgroup>
          <h1><a href="/">spektel-sensor</a></h1>
        </hgroup>
        <a href="#nav" class="menu"><span class='icons'>☰</span></a>
        <nav role="navigation">
          <ul>
            <li>
              <a href="/" title="spektel-sensor">Home</a>
            </li>
            
            
                <li><a href="/about" >About</a></li>
            
                <li><a href="https://github.com/csc13/spektel-sensor" target="_blank">Github</a></li>
            

          </ul>
        </nav>
      </div>
    </header>


<section class="article">


  <div class="overlay"></div>
  <div class="featured-image" style="background-image: url(/images/Board_REV_B.jpg)"></div>



      <article class="wrap post">
        <header class="post-header">
          <hgroup>
            <h1>XMEGA, ASF and TWI/I2C</h1>
            <p class="date">Jan 03, 2015</p>
            <p class="intro">Getting TWI and I2C running with the Atmel ASF and XMEGA</p>
          </hgroup>
        </header>
    
        <p>One of the main XMEGA features the sensor uses is the I2C (Inter-Integrated Circut) or TWI
(Two-Wire-Interface) serial data bus. It is used for the <code>Spektrum RC Telemetry X-Bus</code> as 
a Slave and for the <code>Bosch BMP180</code> pressure sensor as a Master. In both cases the XMEGA
hardware capabilities are used.</p>

<p>While the first prototyping with an Arduino was quite simple, it took me some time to
figure things out using the XMEGA and ASF (Atmel Software Framework). In my opinion it is
because the XMEGA is far less used by makers and hobbyists compared to the ATMEGA series.
And the ASF functions have some undocumented unexpected behaviour. The main source I used
have been the XMEGA datasheet and AFS Quickstart examples, which you can find on the Atmel
website and at the end of some library header files as comments.</p>

<p>I will try to give an overview, pitfalls and solutions in this article. May it help others
to save some time.</p>

<h3 id="xmega-twi-bridge-mode">XMEGA TWI Bridge Mode</h3>
<p>The <code>ATXMEGA32E5</code> offers a feature called Bridge mode. And I didn’t found much help on this.
If you go to the ATXMEGA32E5 datasheet it lists the following Alternate Pin Functions 
(in chapter 32.2) for TWI:</p>

<ul>
  <li>PORT C - PC0 (Pin 16) - SDA</li>
  <li>PORT C - PC1 (Pin 15) - SCL</li>
  <li>PORT D - PD0 (Pin 28) - SDA (TWID (Bridge))</li>
  <li>PORT D - PD1 (Pin 27) - SCL (TWID (Bridge))</li>
</ul>

<p>Chapter 22 of the Atmel datasheet gives some more hints:</p>

<ul>
  <li>Bridge mode with independent and simultaneous master and slave operation</li>
  <li>Independent timeout counters in master and slave (Bridge mode support)</li>
  <li>By using the bridge option, the slave can be mapped to different pin
locations</li>
  <li>The master and slave can support 100kHz, 400kHz and 1MHz bus frequency</li>
  <li>It is also possible to enable the bridge mode. In this mode, the slave I/O pins are 
selected from an alternative port, enabling independent and simultaneous master and slave operation</li>
  <li>PORTC has one TWI. Notation of this peripheral is TWIC</li>
  <li>Alternative TWI Slave location in bridge mode is on PORTD</li>
</ul>

<p>Chapter 18 of the <code>Atmel ATXMEGA Guide</code> adds the following:</p>

<p>“When enabling the bridge mode, both master and slave can be active at the same time, each 
with its specific IO pins. Refer to the device datasheet to see which actual I/O port is 
used as alternative port selection for the slave in bridge mode.”</p>

<p><strong>Following this we have to use Port D as TWI slave and PORT C as TWI master.</strong></p>

<p>So the setup look like the following:
<code>conf_board.h</code></p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> //Part of conf_board.h
<span class="lineno"> 2</span> // TWIM for BMP180
<span class="lineno"> 3</span> #define TWI_MASTER       TWIC
<span class="lineno"> 4</span> #define TWI_MASTER_PORT  PORTC
<span class="lineno"> 5</span> #define TWI_MASTER_ADDR  0xEF
<span class="lineno"> 6</span> #define TWI_SPEED        1000000
<span class="lineno"> 7</span> 	 
<span class="lineno"> 8</span> // TWIS for XBUS
<span class="lineno"> 9</span> #define TWI_SLAVE        TWIC
<span class="lineno">10</span> #define TWI_SLAVE_PORT  PORTD</code></pre></div>

<p><code>conf_twim.h</code> looks like this:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> #define CONF_TWIM_INTLVL        TWI_MASTER_INTLVL_MED_gc
<span class="lineno">2</span> #define CONF_PMIC_INTLVL        PMIC_MEDLVLEN_bm</code></pre></div>

<p>In the sensor coding, the TWI initialization code is in the <code>spektel.c</code> file:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> bool spektel_init() { //TWI_t *twis) {
<span class="lineno"> 2</span> // Initialize ports
<span class="lineno"> 3</span> TWI_MASTER_PORT.PIN0CTRL = PORT_OPC_WIREDAND_gc;
<span class="lineno"> 4</span> TWI_MASTER_PORT.PIN1CTRL = PORT_OPC_WIREDAND_gc;
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> irq_initialize_vectors();
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> sysclk_enable_peripheral_clock(<span class="ni">&amp;TWI_MASTER);</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> twi_bridge_enable(<span class="ni">&amp;TWI_MASTER);</span>
<span class="lineno">11</span> //twi_fast_mode_enable(<span class="ni">&amp;TWI_MASTER);</span>
<span class="lineno">12</span> //twi_slave_fast_mode_enable(<span class="ni">&amp;TWI_SLAVE);</span>
<span class="lineno">13</span> 
<span class="lineno">14</span> twi_options_t m_options = {
<span class="lineno">15</span> 	.speed     = TWI_SPEED,
<span class="lineno">16</span> 	.chip      = TWI_MASTER_ADDR,
<span class="lineno">17</span> 	.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), TWI_SPEED)
<span class="lineno">18</span> };</code></pre></div>

<p>As you can see the bridge mode works without the fast modes.</p>

<p>Make sure you call <code>sysclk_init();</code> at the beginning of your code and change <code>conf_clock.h</code>
to the desired clock speed.</p>

<p>Initializing the master:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> status_code = twi_master_init(<span class="err">&amp;</span>TWI_MASTER, <span class="ni">&amp;m_options);</span>
<span class="lineno">2</span> if(status_code != STATUS_OK) printf(&quot;spektel_init.twi_master_init status: %x&quot;, status_code);
<span class="lineno">3</span> twi_master_enable(<span class="ni">&amp;TWI_MASTER);</span></code></pre></div>

<h3 id="twi-x-bus-slave-initialization">TWI X-Bus slave initialization</h3>
<p>We need to calculate the TWI slave address, the XMEGA TWI hardware implementation
listens to. The TWI master always sends a 7-bit slave address to address one slave 
listening on the bus. There is a register for this address, but in our case the sensor
should behave like a multiple personality and react to three sensor addresses.</p>

<p>As muknukem (am rcgroups.com and rc-heli.de forums member) re-engineered, the Spektrum RC
X-Bus starts to enumerates the sensor addresses 70ms after the power is stable. It sends a 
request for each address between 0x01 to 0x7D, with pauses of 13ms in two cycles. Each
sensor the Spektrum transmitters know have one or more (the GPS sensor uses two, because
it needs to send more data) addresses. So the number of different sensors is theoretically
limited by the number of the requested addresses. On the other hand all is fixed and simple.  </p>

<p>The good thing is, the TM1000 telemetry module doesn’t care, if the sensor reacts to a request for
lets say address 0x01 with 0x0A for the Powerbox sensor. It uses what the sensor sends back.
After the startup procedure, the TM1000 only asks for sensors we sent a response for
(again, the address sent back is the interesting one).</p>

<p>The XMEGA reacts to all addresses by setting this register:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> TWIC.SLAVE.CTRLA |= 0x02; // PMEN: Promiscuous Mode Enable - address match logic disabled, react to everything</code></pre></div>

<p>But to save the interrupt routines some work it could be useful to set the XMEGA hardware
to react not to all. On the ATMEGA and Arduinos the following code works:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> uint8_t twi_slave_address = 0x00;
<span class="lineno"> 2</span> status_code_t status_code = 0x00;
<span class="lineno"> 3</span> // calculate slave address for single sensor (two TWI addresses are only support by XMEGA)
<span class="lineno"> 4</span> if( CURRENT_TEL ) {
<span class="lineno"> 5</span> 	twi_slave_address |= CURRENT_SENS;
<span class="lineno"> 6</span> }
<span class="lineno"> 7</span> if( POWERBOX_TEL ) {
<span class="lineno"> 8</span> 	twi_slave_address |= POWERBOX_SENS;
<span class="lineno"> 9</span> }
<span class="lineno">10</span> if( VARIO_TEL ) {
<span class="lineno">11</span> 	twi_slave_address |= VARIO_SENS;
<span class="lineno">12</span> }</code></pre></div>

<p><em>In my experience, his is not working for the XMEGA!</em> And two addresses can be applied with
respect to the datasheet, but not three.</p>

<p>So the further code looks like this:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> sysclk_enable_peripheral_clock(<span class="ni">&amp;TWI_SLAVE);</span>
<span class="lineno">2</span> TWI_SlaveInitializeDriver(<span class="err">&amp;</span>slave, <span class="err">&amp;</span>TWI_SLAVE, *slave_process);</code></pre></div>

<p>Where <code>*slave_process</code> is a pointer to the a function reacting on requests from the master.
I will get into more detail later on.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> TWI_SlaveInitializeModule(<span class="err">&amp;</span>slave, twi_slave_address, TWI_SLAVE_INTLVL_MED_gc);
<span class="lineno">2</span> 	
<span class="lineno">3</span> //TWI address for Current, Powerbox and Vario and flight pack capacity
<span class="lineno">4</span> TWIC.SLAVE.ADDRMASK = (0x7F <span class="err">&lt;</span><span class="nt">&lt; 1</span><span class="err">)</span> <span class="err">;</span>  <span class="err">//</span><span class="na">mask</span> <span class="err">(</span><span class="na">1</span><span class="err">)</span> <span class="na">all</span> <span class="na">address</span> <span class="na">bits</span><span class="err">,</span> <span class="na">which</span> <span class="na">are</span> <span class="na">different</span> <span class="na">between</span> <span class="na">all</span> <span class="na">used</span> <span class="na">sensors</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="na">for</span> <span class="err">(</span><span class="na">uint8_t</span> <span class="na">i =</span><span class="err"> </span><span class="s">0;</span> <span class="na">i</span> <span class="err">&lt;</span> <span class="na">TWIS_SEND_BUFFER_SIZE</span><span class="err">;</span> <span class="na">i</span><span class="err">++)</span> <span class="err">{</span>
<span class="lineno">7</span> 	<span class="na">slave</span><span class="err">.</span><span class="na">receivedData</span><span class="err">[</span><span class="na">i</span><span class="err">]</span> <span class="err">=</span> <span class="na">0</span><span class="err">;</span>
<span class="lineno">8</span> <span class="err">}</span></code></pre></div>

<p>The magic is done by  writing  0x4B to the upper 7bits of the Slave ADDRMASK Address Mask Register.
The datasheet says:</p>

<p>“If ADDREN is set to zero, ADDRMASK can be loaded with a 7-bit slave address mask. Each bit in ADDRMASK
can mask (disable) the corresponding address bit in the ADDR register. If the mask bit is one, the address match
between the incoming address bit and the corresponding bit in ADDR is ignored; i.e., masked bits will always
match.”</p>

<p>We leave ADDREN (Bit 0 of the same register) to zero. The mask is calculated as following:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> 0000 0011	Current Sensor address
<span class="lineno">2</span> 0000 1010	Powerbox Sensor address
<span class="lineno">3</span> 0100 0000   Vario Sensor address
<span class="lineno">4</span> 0011 0100   Flight Cap Sensor address
<span class="lineno">5</span> -----------------------------------
<span class="lineno">6</span> 0111 1111   = 0x7F as Address Mask</code></pre></div>

<p>The last part of the code initializes the receive buffer.</p>

<h3 id="twi-slave-operation">TWI slave operation</h3>
<p>Whenever the master request some data from the slave an interrupt routine within the ASF
is called and will ask some client code for the sensor values. And here is the first odd
part of the ASF TWI implementation in my humble opinion. The following was posted on avrfreaks.net
from me.</p>

<p>When looking on the twis.c implementation for TWI slaves it misses an important functionality
to me. Looking at the Arduino Wire library it provides a <code>onReceive()</code> and <code>onRequest()</code> 
where the first one is to receive data from the master and the second is to respond to 
the masters request.When looking into the ASF TWI slave implementation there is only one 
callback for the <code>onReceive()</code> case. So I didn’t figure out what the way to handle master 
requests would be. By initializing the TWI slave module the following is used (same as above):</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> sysclk_enable_peripheral_clock(<span class="ni">&amp;TWI_SLAVE);</span>
<span class="lineno">2</span> TWI_SlaveInitializeDriver(<span class="err">&amp;</span>slave, <span class="err">&amp;</span>TWI_SLAVE, *slave_process);
<span class="lineno">3</span> TWI_SlaveInitializeModule(<span class="err">&amp;</span>slave, twi_slave_address, TWI_SLAVE_INTLVL_MED_gc);</code></pre></div>

<p>Where <code>*slave_process</code> is the callback. Looking in <code>twis.c</code> it looks like the following. 
<code>TWI_SlaveDataHandler(...)</code> is called (via two functions calls) in the TWIx Interrupt 
Service Routine.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> void TWI_SlaveDataHandler(TWI_Slave_t *twi)
<span class="lineno"> 2</span> {
<span class="lineno"> 3</span> 	if (twi-&gt;interface-&gt;SLAVE.STATUS <span class="err">&amp;</span> TWI_SLAVE_DIR_bm) {
<span class="lineno"> 4</span> 		TWI_SlaveWriteHandler(twi);
<span class="lineno"> 5</span> 	} else {
<span class="lineno"> 6</span> 		TWI_SlaveReadHandler(twi);
<span class="lineno"> 7</span> 	}
<span class="lineno"> 8</span> }
<span class="lineno"> 9</span> 
<span class="lineno">10</span> //and later
<span class="lineno">11</span> 
<span class="lineno">12</span> /* brief TWI slave read interrupt handler.
<span class="lineno">13</span>  *  Handles TWI slave read transactions and responses.
<span class="lineno">14</span>  *  param twi The TWI_Slave_t struct instance.
<span class="lineno">15</span>  */
<span class="lineno">16</span> void TWI_SlaveReadHandler(TWI_Slave_t *twi)
<span class="lineno">17</span> {
<span class="lineno">18</span> 	/* Enable stop interrupt. */
<span class="lineno">19</span> 	uint8_t currentCtrlA = twi-&gt;interface-&gt;SLAVE.CTRLA;
<span class="lineno">20</span> 	twi-&gt;interface-&gt;SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
<span class="lineno">21</span> 
<span class="lineno">22</span> 	/* If free space in buffer. */
<span class="lineno">23</span> 	if (twi-&gt;bytesReceived <span class="nt">&lt; TWIS_RECEIVE_BUFFER_SIZE</span><span class="err">)</span> <span class="err">{</span>
<span class="lineno">24</span> 		<span class="err">/*</span> <span class="na">Fetch</span> <span class="na">data</span> <span class="err">*/</span>
<span class="lineno">25</span> 		<span class="na">uint8_t</span> <span class="na">data =</span><span class="err"> </span><span class="s">twi-</span><span class="nt">&gt;</span>interface-&gt;SLAVE.DATA;
<span class="lineno">26</span> 		twi-&gt;receivedData[twi-&gt;bytesReceived] = data;
<span class="lineno">27</span> 
<span class="lineno">28</span> // look here &gt;&gt;&gt;&gt;&gt;&gt;&gt;
<span class="lineno">29</span> 		/* Process data. */
<span class="lineno">30</span> 		twi-&gt;Process_Data();
<span class="lineno">31</span> 
<span class="lineno">32</span> 		twi-&gt;bytesReceived++;
<span class="lineno">33</span> 
<span class="lineno">34</span> 		/* If application signalling need to abort (error occured),
<span class="lineno">35</span> 		 * complete transaction and wait for next START. Otherwise
<span class="lineno">36</span> 		 * send ACK and wait for data interrupt.
<span class="lineno">37</span> 		 */
<span class="lineno">38</span> 		if (twi-&gt;abort) {
<span class="lineno">39</span> 			twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
<span class="lineno">40</span> 			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
<span class="lineno">41</span> 			twi-&gt;abort = false;
<span class="lineno">42</span> 		} else {
<span class="lineno">43</span> 			twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
<span class="lineno">44</span> 		}
<span class="lineno">45</span> 	}
<span class="lineno">46</span> 	/* If buffer overflow, send NACK and wait for next START. Set
<span class="lineno">47</span> 	 * result buffer overflow.
<span class="lineno">48</span> 	 */
<span class="lineno">49</span> 	else {
<span class="lineno">50</span> 		twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
<span class="lineno">51</span> 		                              TWI_SLAVE_CMD_COMPTRANS_gc;
<span class="lineno">52</span> 		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
<span class="lineno">53</span> 	}
<span class="lineno">54</span> }</code></pre></div>

<p>So you see, that for the read handler the Process_Data callback handler is placed. Looking
on the write handler this callback is missing. The following change of <code>twis.c</code> works 
for me (I only need the onRequest() so I used the same callback function):</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> /* brief TWI slave write interrupt handler.
<span class="lineno"> 2</span>  *  Handles TWI slave write transactions and responses.
<span class="lineno"> 3</span>  *
<span class="lineno"> 4</span>  *  param twi The TWI_Slave_t struct instance.
<span class="lineno"> 5</span>  */
<span class="lineno"> 6</span> void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
<span class="lineno"> 7</span> {
<span class="lineno"> 8</span> 	/* If NACK, slave write transaction finished. */
<span class="lineno"> 9</span> 	if ((twi-&gt;bytesSent &gt; 0) <span class="err">&amp;&amp;</span> (twi-&gt;interface-&gt;SLAVE.STATUS <span class="err">&amp;</span>
<span class="lineno">10</span> 	                             TWI_SLAVE_RXACK_bm)) {						 
<span class="lineno">11</span> 
<span class="lineno">12</span> 		twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
<span class="lineno">13</span> 		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
<span class="lineno">14</span> //&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; added the next line for callback		
<span class="lineno">15</span> 		twi-&gt;Process_Data();
<span class="lineno">16</span> 	}
<span class="lineno">17</span> 	/* If ACK, master expects more data. */
<span class="lineno">18</span> 	else {
<span class="lineno">19</span> 		if (twi-&gt;bytesSent <span class="nt">&lt; TWIS_SEND_BUFFER_SIZE</span><span class="err">)</span> <span class="err">{</span>
<span class="lineno">20</span> 			<span class="na">uint8_t</span> <span class="na">data =</span><span class="err"> </span><span class="s">twi-</span><span class="nt">&gt;</span>sendData[twi-&gt;bytesSent];
<span class="lineno">21</span> 			twi-&gt;interface-&gt;SLAVE.DATA = data;
<span class="lineno">22</span> 			twi-&gt;bytesSent++;
<span class="lineno">23</span> 
<span class="lineno">24</span> 			/* Send data, wait for data interrupt. */
<span class="lineno">25</span> 			twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
<span class="lineno">26</span> 		}
<span class="lineno">27</span> 		/* If buffer overflow. */
<span class="lineno">28</span> 		else {
<span class="lineno">29</span> 			twi-&gt;interface-&gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
<span class="lineno">30</span> 			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
<span class="lineno">31</span> 		}
<span class="lineno">32</span> 	}
<span class="lineno">33</span> }</code></pre></div>

<p>I don’t think such changes should be made to a standard library. But I invested to much time
to understand the framework, so that it was easier for me than a rewrite.</p>

<h3 id="sending-out-data">Sending out data</h3>
<p>If the slave_process function is called via the <code>twi-&gt;Process_Data()</code> function pointer,
<code>spektel_write_sensor_data()</code> is called sending out the data in a round robin pattern.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> /**
<span class="lineno"> 2</span>  * \brief Write the values of a sensor to the (I2C/TWI) X-Bus. Since the TM1000 doesn&#39;t match
<span class="lineno"> 3</span>  *        the requested address to the delivered address this function implements a round robin.	
<span class="lineno"> 4</span>  */
<span class="lineno"> 5</span> void spektel_write_sensor_data() {
<span class="lineno"> 6</span> 	uint8_t i = 0;
<span class="lineno"> 7</span> 	if(slave.status == TWIS_STATUS_READY) {
<span class="lineno"> 8</span> 		for(i = 0; i <span class="nt">&lt; DATA_LENGTH</span> <span class="err">&amp;&amp;</span> <span class="na">i</span> <span class="err">&lt;</span> <span class="na">TWIS_SEND_BUFFER_SIZE</span><span class="err">;</span> <span class="na">i</span><span class="err">++)</span> <span class="err">{</span>
<span class="lineno"> 9</span> 			<span class="na">if</span><span class="err">(</span><span class="na">toggle =</span><span class="s">=</span> <span class="na">0</span><span class="err">)</span> <span class="err">{</span>
<span class="lineno">10</span> 				<span class="na">slave</span><span class="err">.</span><span class="na">sendData</span><span class="err">[</span><span class="na">i</span><span class="err">]</span> <span class="err">=</span> <span class="na">powerbox_data</span><span class="err">.</span><span class="na">byte</span><span class="err">[</span><span class="na">i</span><span class="err">];</span>
<span class="lineno">11</span> 			<span class="err">}</span> <span class="na">else</span> <span class="na">if</span> <span class="err">(</span><span class="na">toggle =</span><span class="s">=</span> <span class="na">1</span><span class="err">)</span> <span class="err">{</span>
<span class="lineno">12</span> 				<span class="na">slave</span><span class="err">.</span><span class="na">sendData</span><span class="err">[</span><span class="na">i</span><span class="err">]</span> <span class="err">=</span> <span class="na">current_data</span><span class="err">.</span><span class="na">byte</span><span class="err">[</span><span class="na">i</span><span class="err">];</span>
<span class="lineno">13</span> 			<span class="err">}</span> <span class="na">else</span> <span class="na">if</span> <span class="err">(</span><span class="na">toggle =</span><span class="s">=</span> <span class="na">2</span><span class="err">)</span> <span class="err">{</span>
<span class="lineno">14</span> 				<span class="na">slave</span><span class="err">.</span><span class="na">sendData</span><span class="err">[</span><span class="na">i</span><span class="err">]</span> <span class="err">=</span> <span class="na">vario_data</span><span class="err">.</span><span class="na">byte</span><span class="err">[</span><span class="na">i</span><span class="err">];</span>
<span class="lineno">15</span> 			<span class="err">}</span>
<span class="lineno">16</span> 		<span class="err">}</span>
<span class="lineno">17</span> 	<span class="err">}</span>
<span class="lineno">18</span> 	<span class="na">if</span><span class="err">(++</span><span class="na">toggle</span> <span class="nt">&gt;</span> 2) toggle = 0;
<span class="lineno">19</span> }</code></pre></div>

<p>All we need to do is to write the data to the <code>slave.sendData[]</code> array. Since each X-Bus
data package is 16 byte long starting with the slave address in the first byte, a zero byte
and then the data, we can send all data in one chunk. I just changed the buffer sizes in the
<code>twis.h</code> file to 16 byte:</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno">1</span> /* Buffer size defines. */
<span class="lineno">2</span> #define TWIS_RECEIVE_BUFFER_SIZE         16
<span class="lineno">3</span> #define TWIS_SEND_BUFFER_SIZE            16</code></pre></div>

<p>The format of each sensor data package is defined by the Spektrum TM1000 module and translated
to data structures in the <code>spektel.h</code> file. If the measuring code of the sensor has new data,
it writes it to these structures (for example <code>spektel_sensor_powerbox_t</code>) and calls the 
<code>spektel_write_pwerbox_sens(...)</code> function which translates it into an 16 byte array for the
next TWI <code>onRequest()</code> action.</p>

<p>I hope the whole process on the slave side gets clear now.</p>

<h3 id="communication-as-a-twi-master">Communication as a TWI Master</h3>
<p>Setting up the connection to the BMP180, where the XMEGA is the Master and the BMP180 is the
slave took me some time to figure out. But one by one!</p>

<h3 id="getting-the-hardware-right">Getting the hardware right</h3>
<p>The I2C / TWI bus used to connect the Bosch BMP180 pressure sensor has two pull-up resistors.
This is the general design of each TWI bus and used on the X-Bus TM1000 side as well. One
resistor for each line (SDA/SCL) no matter how many slaves are connected to pull the open drain
signal lines to Vcc (3.3V in our case) if needed. If you work with a 5V µC you will need
an additional level shifter.</p>

<p>I tried to be smarter than the datasheet and put 2.7K in. It turned out, that they are two
small to drive the SDA and SCL lines to GND fast enough. So use 4.7K for the TWI/I2Cs instead.
For the X-Bus 2.7K seems to work, but the connection using a 20cm cable is much longer as the
1cm data lines on the board for the BMP180.</p>

<p>I got myself a Saleae Logic8 logic analyser. Why it is probably not the most needed tool,
in this case it helps a lot. And it brings analog monitoring functionality as well. From the
signal shape below I figured out that something goes wrong. The XMEGA trys to pull down the 
signal resulting in a slow drop of the signal voltage.</p>

<figure>
	<img src="/images/saleae_logic_i2c_bmp180_faulty.jpg" />
	<figcaption>Monitoring the I2C bus to the BMP180</figcaption>
</figure>

<p>It has to look this way. The sequence just reads the static device ID for test purposes.</p>

<figure>
	<img src="/images/saleae_logic_i2c_bmp180.jpg" />
	<figcaption>Monitoring the I2C bus to the BMP180</figcaption>
</figure>

<h3 id="initializing-the-master">Initializing the Master</h3>
<p>Here the code from the TWI initialization routine above again in short form: </p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> bool spektel_init() {
<span class="lineno"> 2</span> // Initialize ports
<span class="lineno"> 3</span> TWI_MASTER_PORT.PIN0CTRL = PORT_OPC_WIREDAND_gc;
<span class="lineno"> 4</span> TWI_MASTER_PORT.PIN1CTRL = PORT_OPC_WIREDAND_gc;
<span class="lineno"> 5</span> irq_initialize_vectors();
<span class="lineno"> 6</span> sysclk_enable_peripheral_clock(<span class="ni">&amp;TWI_MASTER);</span>
<span class="lineno"> 7</span> twi_bridge_enable(<span class="ni">&amp;TWI_MASTER);</span>
<span class="lineno"> 8</span> twi_options_t m_options = {
<span class="lineno"> 9</span> 	.speed     = TWI_SPEED,
<span class="lineno">10</span> 	.chip      = TWI_MASTER_ADDR,
<span class="lineno">11</span> 	.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), TWI_SPEED)
<span class="lineno">12</span> };</code></pre></div>

<p>Now we can directly start writing to the slave devices. In our case, the BMP180
provides EEPROM style registers for the communication. So this is a standard style
for TWI communication.</p>

<p>Write: Write the 7-bit slave address and the LSB (most right bit) bit 1 for read and 0 for 
write. As it turns out this was the next pitfall the ASF provides for me. In all of the 
Atmel code, I worked with the 7-bit slave address more or less like with an 8-bit address 
(expect for direct access to the registers). But the ASF library functions 
<code>twi_master_write</code>and <code>twi_master_read</code> add the LSB dependent on the read or write function.
I guess this is part of the TWI-EEPROM access protocol. Where the Bosch datasheet talks
about 0xEF for read and 0xEE for write, the ASF functions need 0x77! With this we can read 
and write bytes:</p>

<p>Here the code from the TWI initialization routine above again in short form: </p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> /** Read a byte
<span class="lineno"> 2</span>  *
<span class="lineno"> 3</span>  * \param reg_addr the register address.
<span class="lineno"> 4</span>  * \param byte the data to be read.
<span class="lineno"> 5</span>  *
<span class="lineno"> 6</span>  * \return status of read operation
<span class="lineno"> 7</span>  */
<span class="lineno"> 8</span> static uint8_t read_byte(const uint8_t reg_addr, uint8_t *byte)
<span class="lineno"> 9</span> {
<span class="lineno">10</span> 	twi_package_t r_packet = {
<span class="lineno">11</span> 		.addr		 = { reg_addr },
<span class="lineno">12</span> 		.addr_length = 1,
<span class="lineno">13</span> 		.chip        = BMP180_ADDR_READ &gt;&gt; 1,
<span class="lineno">14</span> 		.buffer      = byte,
<span class="lineno">15</span> 		.length      = 1,
<span class="lineno">16</span> 		.no_wait     = false
<span class="lineno">17</span> 	};
<span class="lineno">18</span> 	return twi_master_read(<span class="err">&amp;</span>TWI_MASTER, <span class="ni">&amp;r_packet);</span>
<span class="lineno">19</span> }
<span class="lineno">20</span> 
<span class="lineno">21</span> /** Write a byte
<span class="lineno">22</span>  *
<span class="lineno">23</span>  * \param reg_addr the register address.
<span class="lineno">24</span>  * \param byte the data to be written.
<span class="lineno">25</span>  *
<span class="lineno">26</span>  * \return status of operation
<span class="lineno">27</span>  */
<span class="lineno">28</span> static uint8_t write_byte(const uint8_t reg_addr, uint8_t byte)
<span class="lineno">29</span> {
<span class="lineno">30</span> 	twi_package_t w_packet = {
<span class="lineno">31</span> 		.addr		 = { reg_addr },
<span class="lineno">32</span> 		.addr_length = sizeof(reg_addr),
<span class="lineno">33</span> 		.chip        = BMP180_ADDR_WRITE &gt;&gt; 1,
<span class="lineno">34</span> 		.buffer      = <span class="err">&amp;</span>byte,
<span class="lineno">35</span> 		.length      = sizeof(uint8_t),
<span class="lineno">36</span> 		.no_wait     = false
<span class="lineno">37</span> 	};
<span class="lineno">38</span> 
<span class="lineno">39</span> 	return twi_master_write(<span class="err">&amp;</span>TWI_MASTER, <span class="ni">&amp;w_packet);</span>
<span class="lineno">40</span> }</code></pre></div>

<p>For the .chip you can use 0x77 or the datasheet address shifted to the right. On the bus
the XMEGA will call with 0xEF and 0XEF showing if it wants to read or write. </p>

<h3 id="reading-many-bytes">Reading many bytes</h3>
<p>Another pitfall was, that the Atmel ASF seems to expect the MSB (in this case higher <strong>byte</strong> 
of a 16 bit value) and LSB (lower byte) order different than the Bosch BMP180. The 
library supports to read multiple bytes in one read. Doing so, the BMP180 respondes with 
the MSB, the Master sends an <code>ACK</code> requesting more data. Then the BMP180 sends the LSB
and a <code>NAK</code> follows to finish the communication and release the bus.
But the ASF gives back that values in the wrong order LSB-MSB. So a swap operation is needed
at the end. Either the BMP180 or the ASF gets it wrong!?  </p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="lineno"> 1</span> /** Read word (16bit)
<span class="lineno"> 2</span>  *
<span class="lineno"> 3</span>  * \param reg_addr the register address.
<span class="lineno"> 4</span>  * \param word the data to be read.
<span class="lineno"> 5</span>  *
<span class="lineno"> 6</span>  * \return status of operation
<span class="lineno"> 7</span>  */
<span class="lineno"> 8</span> static uint8_t read_word(const uint8_t reg_addr, uint16_t *word)
<span class="lineno"> 9</span> {
<span class="lineno">10</span> 	uint8_t err;
<span class="lineno">11</span> 	
<span class="lineno">12</span> 	twi_package_t r_packet = {
<span class="lineno">13</span> 		.addr		 = { reg_addr },
<span class="lineno">14</span> 		.addr_length = sizeof(reg_addr),
<span class="lineno">15</span> 		.chip        = BMP180_ADDR_READ &gt;&gt; 1,
<span class="lineno">16</span> 		.buffer      = word,
<span class="lineno">17</span> 		.length      = sizeof(uint16_t),
<span class="lineno">18</span> 		.no_wait     = false
<span class="lineno">19</span> 	};
<span class="lineno">20</span> 	err = twi_master_read(<span class="err">&amp;</span>TWI_MASTER, <span class="ni">&amp;r_packet);</span>
<span class="lineno">21</span> 	
<span class="lineno">22</span> 	uint8_t lsb = (*word) &gt;&gt; 8;
<span class="lineno">23</span> 	(*word) = ((*word) <span class="err">&lt;</span><span class="nt">&lt; 8</span><span class="err">)</span> <span class="err">|</span> <span class="na">lsb</span><span class="err">;</span>
<span class="lineno">24</span> 	
<span class="lineno">25</span> 	<span class="na">return</span> <span class="na">err</span><span class="err">;</span>
<span class="lineno">26</span> <span class="err">}</span></code></pre></div>


          
      <a class="share" href="https://twitter.com/intent/tweet?text=&quot;XMEGA, ASF and TWI/I2C&quot;%20%20via%20&#64;" data-dnt="true">Share</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

      


      </article>

    </section>
</div>

<div class="push"></div>
  <footer>
    <aside class="wrap">
      <ol class="prev-posts">
        <p class="list-title">Recent Posts</p>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="/articles/Getting_the_parts" title="Getting the parts">Getting the parts </a></span>
              <span class="date">Jan 25, 2015</span>
            </li>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="/articles/XMEGA_ASF_TWI" title="XMEGA, ASF and TWI/I2C">XMEGA, ASF and TWI/I2C </a></span>
              <span class="date">Jan 03, 2015</span>
            </li>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="/articles/Sensor_setup" title="Sensor setup">Sensor setup </a></span>
              <span class="date">Dec 31, 2014</span>
            </li>
        
      </ol>
      
      <div class="social">
        <ul>
            <li><a id="mail" href="mailto:git@cescholz.de"><span class="foot-link">Contact Me</span></a></li>
            
            
            
            
            
        </ul>
    </div>
    </aside>
    <small>&copy; 2015 Christian. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://jekyll.gtat.me/about">Balzac</a> theme.</small>
  </footer>

  <!-- If they're out, get some from the cellar -->
  <script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
  <script src="/assets/js/retina.min.js"></script>

  <!-- Custom JS -->
  <script src="/assets/js/scripts.js"></script>
  

  </body>
</html>
