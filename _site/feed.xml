<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">spektel-sensor</title>
<subtitle type="text">Spektrum capacity sensor</subtitle>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="/feed.xml" />
<link rel="alternate" type="text/html" href="" />
<updated>2015-02-23T23:37:46+01:00</updated>
<id>/</id>
<author>
  <name>Christian</name>
  <uri>/</uri>
  <email>git@cescholz.de</email>
</author>


<entry>
  <title type="html"><![CDATA[Firmware Part 3]]></title>
  <link rel="alternate" type="text/html" href="/articles/Software_part_3" />
  <id>/articles/Software_part_3</id>
  <published>2015-02-23T00:00:00+01:00</published>
  <updated>2015-02-23T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;In the last &lt;a href=&quot;/articles/Software_part_2&quot;&gt;post&lt;/a&gt; I explained the calculation of the current 
using the ADC measurements. Now we come to the calculation of the used capacity.&lt;/p&gt;

&lt;h3 id=&quot;what-we-need&quot;&gt;What we need&lt;/h3&gt;
&lt;p&gt;We want to get the battery capacity used in something like mAh. This is near to the used
energy if we do the incorrect assumption, that the voltage is fixed. But for the Ampere-hour
we don’t need the voltage.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/ampere-hour.png&quot; /&gt;
	&lt;figcaption&gt;We need to get the ampere-hour&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;What we want to calculate is the red area under the current curve. This is an integral
over the time.&lt;/p&gt;

&lt;h3 id=&quot;what-we-have&quot;&gt;What we have&lt;/h3&gt;
&lt;p&gt;The sensor measures the current in timer triggered intervals (in our case 40ms, but the
time is variable in the calculation).&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/digitalized_current_curve.png&quot; /&gt;
	&lt;figcaption&gt;The digitalized current curve&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;We store the actual measurement &lt;code&gt;res2&lt;/code&gt; and time of the measurement &lt;code&gt;time2&lt;/code&gt; and the 
measurement before &lt;code&gt;res1&lt;/code&gt; and &lt;code&gt;time1&lt;/code&gt;. After each calculation &lt;code&gt;res2&lt;/code&gt; becomes &lt;code&gt;res1&lt;/code&gt; and
a new measurement is done to &lt;code&gt;res2&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-calculation&quot;&gt;The calculation&lt;/h3&gt;
&lt;p&gt;We need to get the surface of the blue tetragon. If we think of mirroring the same tetragon
on top this is a rectangle with one edge &lt;code&gt;res1 + res2&lt;/code&gt; and the other &lt;code&gt;time2 - time1&lt;/code&gt;.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/integral_Ah.png&quot; /&gt;
	&lt;figcaption&gt;Integrating over time&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This can be easily calculated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Ah = (res1 +res2) * (time2 - time 1) / 2&lt;/code&gt;
or
&lt;code&gt;Ah = (res1 +res2) / 2 * (time2 - time 1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now this is combined with the current calculation of the last &lt;a href=&quot;/articles/Software_part_2&quot;&gt;post&lt;/a&gt;.
We check for clipping. Then calculate the y-axis and subtracting &lt;code&gt;adc_b&lt;/code&gt; for 0A.
Because we then divide by 2 (here a right shift by 1 (&lt;code&gt;&amp;gt;&amp;gt; 1&lt;/code&gt;)) we need to double &lt;code&gt;adc_b&lt;/code&gt;
(again done by a left shift). Then we multiply by the time period and use &lt;code&gt;ACS_R_M_O&lt;/code&gt; 
and the correcting shift by &lt;code&gt;ACS_SHIFT_M&lt;/code&gt; to get mAms (miliamps by miliseconds).&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; uint32_t calc_cap_mAms(uint32_t res1, uint32_t res2, uint32_t time1, uint32_t time2) {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	if( adc_b &amp;gt;= res1 ) res1 = adc_b; //clipping to zero
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	if( adc_b &amp;gt;= res2 ) res2 = adc_b; //clipping to zero
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	//for time in 1ms per bit
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	return (((uint32_t)(((res1 + res2 - (adc_b &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; 1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&amp;gt; 1)  * (time2 - time1) * ACS_R_M_O)) &amp;gt;&amp;gt; ACS_SHIFT_M);	}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So every 40ms we get a very small chunk of mAms used capacity. But even if we have a 32bit
variable this is only 1193 mAh. Not enough for most models.&lt;/p&gt;

&lt;h3 id=&quot;getting-the-result&quot;&gt;Getting the result&lt;/h3&gt;
&lt;p&gt;To transform mAms to mAh we just need to divide the mAms by 3600,000. But if we do that
every measurement with the small chunks, we wont get any result.
So in the main.c the mAms are added and checked if its greater than 1 mAh = 3600,000 mAms.
If so we increase the used capacity in mAh by 1 and substract 3600,000 from the mAms variable.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //Check for capacity overflow
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; if( cap_mAms &amp;gt;= 3600000 ) {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	cap_mAms -= 3600000;  //- one mAh
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 	cap_mAh++;			  //+ one mAh
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 	flight_cap.cap = cap_mAh; //set capa used for flight pack capacity sensor
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 	power.cap1--;         //subtract from capacity output
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; 	//Check for alarm: under BAT_MIN (for powerbox sensor only)
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 	if( power.cap1 &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;= cap_min ) {
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 			power.cap1_alarm = true;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Then we set the flight_cap.cap for the Spektrum Flight Pack Capacity sensor and power.cap1
for the Powerbox Cap1 Sensor value (this is counted down). If power.cap1 goes under 20% of
the full battery capacity the Powerbox alarm is triggered.&lt;/p&gt;

&lt;p&gt;This is it for the core firmware functionality. There are additional setup functions and
all the stuff around the BMP180 pressure / altitude sensor. I might or might not cover that
in a later post.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/Software_part_3&quot;&gt;Firmware Part 3&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on February 23, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Firmware Part 2]]></title>
  <link rel="alternate" type="text/html" href="/articles/Software_part_2" />
  <id>/articles/Software_part_2</id>
  <published>2015-02-22T00:00:00+01:00</published>
  <updated>2015-02-22T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;Last year I promised to give a deeper look in the calculations. So to learn about the start 
of a measurement go back to &lt;a href=&quot;/articles/Software_part_1&quot;&gt;Firmware Part 1&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;adc-base-values&quot;&gt;ADC base values&lt;/h3&gt;
&lt;p&gt;Getting the XMEGA datasheet Analog Digital Converter part, it says that if running in single ended unsigned mode, the
measurement value for GND is 205. This is to be able to measure a 0V voltage without problems.
To get the exact value was a problem. By measurement it was around 160. So I implemented
a self calibration (triggered by the button) to get the exact value at 0V. This variable
is named &lt;code&gt;adc_usig_base&lt;/code&gt; and read from EEPROM.&lt;/p&gt;

&lt;p&gt;The next needed value is the resolution for each bit (called Least Significant Bit).
For 12bit resolution this is 0.4899mV/LSB (constant &lt;code&gt;ADC_MV_12RES&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&quot;measuring-the-voltage&quot;&gt;Measuring the voltage&lt;/h3&gt;
&lt;p&gt;Is easy and just uses a voltage divider of 15.24 ((4.7K + 330) / 330) (constant &lt;code&gt;MAIN_RES_DIV&lt;/code&gt;)
to get the voltage from up to 26V to the measurement range of the XMEGA up to Vcc/1.6 = 2.06V 
in the single ended mode with 12bit resolution.&lt;/p&gt;

&lt;p&gt;The calculation looks like the following:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; uint16_t calc_main_mV(uint16_t res) {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	if( res &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;= adc_usig_base ) { 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 		return 0; //clipping if the input is less than adc_usig_base
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	else {
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 		double _v = (double)((double)(res - adc_usig_base) * (double)ADC_MV_12RES * (double)MAIN_RES_DIV / 10);
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 		return (uint16_t)_v;
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; 	}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We substract the &lt;code&gt;adc_usig_base&lt;/code&gt; to get the correct range and multiply the result with the 12bit 
resolution to get mV. Then we need to multiply with the voltage divider to get the correct voltage.
In this case we divide by 10 to get 10mV as the result unit as needed for the Powerbox voltage
sensor.&lt;/p&gt;

&lt;h3 id=&quot;measuring-the-current&quot;&gt;Measuring the current&lt;/h3&gt;
&lt;p&gt;The main task of the sensor is to read and transmit the current of the main battery pack.
Depending on the current running through the ACS758 hall sensor it outputs a voltage. This
voltage depends on the operating voltage Vcc and the current. The ACS758 can be operated
up to 5V and this is the voltage base in the datasheet. So we need to adjust all datasheet
values be a factor of 3.3V/5V = 0.66. Many values differ by the device, so all constants are
defined in the conf_board.h file (eg. to be able to change to a 200A version).&lt;/p&gt;

&lt;h3 id=&quot;acs758-base-values&quot;&gt;ACS758 base values&lt;/h3&gt;
&lt;p&gt;We use the 100U version with Vcc 3.3V. So we get the following values:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Voltage at Ip = 0A (no current) = 0.6V * 0.66 (for Vcc = 3.3V) = 0.396V (constant &lt;code&gt;ACS758_BASE&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Sensitivity for 1A = 40mV at Vcc = 5V&lt;/li&gt;
  &lt;li&gt;Sensitivity for 1A at Vcc = 3.3V = 26.4mV (by measuring its only 24mV) (constant &lt;code&gt;ACS758_RATE&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Voltage at Ip = 100A = 0.0264V * 100 + 0.396V = 3.036V&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is close to the upper power rail of Vcc = 3.3V and to much for the XMEGA ADC. This
can measure up to Vcc/1.6 = 2.06V in the single ended mode with 12bit resolution. So we need to
apply a voltage divider to bring the Vout from the ACS758 to under 2.06V.&lt;/p&gt;

&lt;p&gt;A voltage divider by 1.64 will do. I used a pair of 3K and 4.7K. This is calculated by
(3K + 4.7K) / 4.7K = 1.638. This looks pretty exact, but don’t forget the resistors have
tolerances by 1-2%. This is the constant &lt;code&gt;CUR_RES_DIV&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the measurement at 0A we can use the self calibration procedure as well. The variable
is called &lt;code&gt;adc_b&lt;/code&gt; and stored in the EEPROM. &lt;/p&gt;

&lt;h3 id=&quot;calculate-the-current&quot;&gt;Calculate the current&lt;/h3&gt;
&lt;p&gt;The formular looks like this:
RES is the 12 bit result from the measurement.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I = (((RES - ADC_USIG_BASE * ADC_MV_12RES * CUR_RES_DIV) - ACS758_BASE) / ACS758_RATE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We substract the ADC base value for 0V and mutliply this with the resolution and 
voltage divider. From this voltage we substract the base voltage for 0A from the sensor and
multiply with the sensitivity to get the current. Then with some mathematic transformations:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I * ACS758_RATE = ((RES - ADC_USIG_BASE) * ADC_MV_12RES * CUR_RES_DIV) - ACS758_BASE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I * ACS758_RATE / ADC_MV_12RES / CUR_RES_DIV = (RES - ADC_USIG_BASE) - (ACS758_BASE / ADC_MV_12RES / CUR_RES_DIV)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I = ((RES - ADC_USIG_BASE) - (ACS758_BASE / ADC_MV_12RES / CUR_RES_DIV)) * (ADC_MV_12RES * CUR_RES_DIV / ACS758_RATE)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;var: &lt;code&gt;ACS_B = (ACS758_BASE / ADC_MV_12RES / CUR_RES_DIV)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;var: &lt;code&gt;ACS_R = (ADC_MV_12RES / ACS758_RATE * CUR_RES_DIV)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I = (RES - ADC_USIG_BASE - ACS_B) * ACS_R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;var: &lt;code&gt;ADC_B = (ADC_USIG_BASE + ACS_B)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I = ((RES - ADC_B) * ACS_R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACS_B&lt;/code&gt; and &lt;code&gt;ACS_R&lt;/code&gt; can be precalculated to save time. &lt;code&gt;ADC_B&lt;/code&gt; can be measured through self 
calibration and is the same as &lt;code&gt;adc_b&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACS758_RATE&lt;/code&gt; will result in A. But for the telemetrie we want the result in 10mA or mA for
the capacity measurement. This is done with &lt;code&gt;_M1&lt;/code&gt; for 10mA and &lt;code&gt;_M&lt;/code&gt; for mA.&lt;/p&gt;

&lt;h3 id=&quot;problems-with-the-calculation&quot;&gt;Problems with the calculation&lt;/h3&gt;
&lt;p&gt;The first problem is, that I use unsigned integer. But this is bad, if the there is some 
drift and the measurement goes under &lt;code&gt;ADC_B&lt;/code&gt;. This can be solved by clipping all results
below this value and simply return 0A.&lt;/p&gt;

&lt;p&gt;The next problem is, that &lt;code&gt;ACS_R&lt;/code&gt; will be a floating point number like 0.0312. If we
switch to 32bit integer and multiply all numbers by a factor x, so the 32bit field will
not be exceeded, this will lead to greater precision of the calculation.
At the end of the calculation we then divide again and get the correct value. If we
multiply by an exponent of 2, we can divide with a simple and fast shift operation.
To calculate the maximum factor in the 32bit limit I used an Excel sheet, you will
find in the Github repository. The calculation the looks like:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;I = (((RES - ADC_B) * ACS_R_O) &amp;gt;&amp;gt; ACS_SHIFT&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ACS_SHIFT&lt;/code&gt; = 5 divides by 32 for example.&lt;/p&gt;

&lt;p&gt;In the calc_measure.c the whole thing looks like this:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; uint16_t calc_mA(uint16_t res) {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	if( adc_b &amp;gt;= res ) { 
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 		return 0; //clipping to zero
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	uint32_t _c = (( (uint32_t)( ((uint32_t)(res - adc_b)) * ((uint32_t)ACS_R_M1_O) ) ) &amp;gt;&amp;gt; ACS_SHIFT_M1);
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	return ((uint16_t)_c);
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In this case the function returns the current in 10mA like required for the Spektrum
telemetry Current sensor.&lt;/p&gt;

&lt;p&gt;In the next round I will explain the capacity measurement. Then we need to add the time
component to the current measurement.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/Software_part_2&quot;&gt;Firmware Part 2&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on February 22, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Getting the parts]]></title>
  <link rel="alternate" type="text/html" href="/articles/Getting_the_parts" />
  <id>/articles/Getting_the_parts</id>
  <published>2015-01-25T00:00:00+01:00</published>
  <updated>2015-01-25T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;For all not having a network of suppliers, ordering all the parts can be a little bit painful.
At least in germany I didn’t find a supplier having all parts even for this simple project.
Then some of the professional suppliers refuse to sell to private persons. And if they do, they
add additional cost for small orders. Ok, at least that is understandable. Electronic 
suppliers for private business like &lt;a href=&quot;http://www.conrad.de&quot;&gt;conrad.de&lt;/a&gt; or &lt;a href=&quot;http://www.reichelt.de&quot;&gt;reichelt.de&lt;/a&gt; 
on the other side have higher prices per piece.&lt;/p&gt;

&lt;p&gt;The main costs of the sensor are produced by only a few components. The hall sensor is clearly
outstanding and probably the reason why many sensors rely on a shunt resistor solution. 
You get the sensor from &lt;a href=&quot;http://farnell.com&quot;&gt;farnell.com&lt;/a&gt; or a partner selling to private 
persons like &lt;a href=&quot;http://hbe-shop.de&quot;&gt;hbe-shop.de&lt;/a&gt;. The BMP180 and many other parts can be order
for a good price at &lt;a href=&quot;http://www.mouser.de&quot;&gt;mouser.de&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here you get a list of the main parts and a possible supplier. All other parts are available
by all of them (and will cost 2€ in total).&lt;/p&gt;

&lt;table width=&quot;100%&quot; style=&quot;border:1px solid #000000; padding:5px; border-collapse:collapse; table-layout:auto;&quot;&gt;
&lt;thead style=&quot;border:1px solid #000000; padding:5px; font-weight:bold;&quot;&gt;
 &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;th style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;Device&lt;/th&gt;
    &lt;th style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;Price&lt;/th&gt;
    &lt;th style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;Supplier&lt;/th&gt;
    &lt;th style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;Order code&lt;/th&gt;
  &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;XMEGA32E5&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;2.26 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;mouser.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;556-ATXMEGA32E5-AU&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;BMP180&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;3.36 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;mouser.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;262-BMP180&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;MCP1826S-3302E/DB&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;0.67 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;mouser.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;579-MCP1826S-3302EDB&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;ACS758LCB-100U&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;8.93 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;hbe-shop.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;2057427&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;JST B4B-ZR&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;0.93 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;conrad.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;740615-62&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;JST S4B-ZR&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;0.65 €&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;conrad.de&lt;/td&gt;
    &lt;td style=&quot;border:1px solid #000000; padding:5px;&quot;&gt;741180-62&lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/Getting_the_parts&quot;&gt;Getting the parts&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on January 25, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[XMEGA, ASF and TWI/I2C]]></title>
  <link rel="alternate" type="text/html" href="/articles/XMEGA_ASF_TWI" />
  <id>/articles/XMEGA_ASF_TWI</id>
  <published>2015-01-03T00:00:00+01:00</published>
  <updated>2015-01-03T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;One of the main XMEGA features the sensor uses is the I2C (Inter-Integrated Circut) or TWI
(Two-Wire-Interface) serial data bus. It is used for the &lt;code&gt;Spektrum RC Telemetry X-Bus&lt;/code&gt; as 
a Slave and for the &lt;code&gt;Bosch BMP180&lt;/code&gt; pressure sensor as a Master. In both cases the XMEGA
hardware capabilities are used.&lt;/p&gt;

&lt;p&gt;While the first prototyping with an Arduino was quite simple, it took me some time to
figure things out using the XMEGA and ASF (Atmel Software Framework). In my opinion it is
because the XMEGA is far less used by makers and hobbyists compared to the ATMEGA series.
And the ASF functions have some undocumented unexpected behaviour. The main source I used
have been the XMEGA datasheet and AFS Quickstart examples, which you can find on the Atmel
website and at the end of some library header files as comments.&lt;/p&gt;

&lt;p&gt;I will try to give an overview, pitfalls and solutions in this article. May it help others
to save some time.&lt;/p&gt;

&lt;h3 id=&quot;xmega-twi-bridge-mode&quot;&gt;XMEGA TWI Bridge Mode&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ATXMEGA32E5&lt;/code&gt; offers a feature called Bridge mode. And I didn’t found much help on this.
If you go to the ATXMEGA32E5 datasheet it lists the following Alternate Pin Functions 
(in chapter 32.2) for TWI:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PORT C - PC0 (Pin 16) - SDA&lt;/li&gt;
  &lt;li&gt;PORT C - PC1 (Pin 15) - SCL&lt;/li&gt;
  &lt;li&gt;PORT D - PD0 (Pin 28) - SDA (TWID (Bridge))&lt;/li&gt;
  &lt;li&gt;PORT D - PD1 (Pin 27) - SCL (TWID (Bridge))&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chapter 22 of the Atmel datasheet gives some more hints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bridge mode with independent and simultaneous master and slave operation&lt;/li&gt;
  &lt;li&gt;Independent timeout counters in master and slave (Bridge mode support)&lt;/li&gt;
  &lt;li&gt;By using the bridge option, the slave can be mapped to different pin
locations&lt;/li&gt;
  &lt;li&gt;The master and slave can support 100kHz, 400kHz and 1MHz bus frequency&lt;/li&gt;
  &lt;li&gt;It is also possible to enable the bridge mode. In this mode, the slave I/O pins are 
selected from an alternative port, enabling independent and simultaneous master and slave operation&lt;/li&gt;
  &lt;li&gt;PORTC has one TWI. Notation of this peripheral is TWIC&lt;/li&gt;
  &lt;li&gt;Alternative TWI Slave location in bridge mode is on PORTD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chapter 18 of the &lt;code&gt;Atmel ATXMEGA Guide&lt;/code&gt; adds the following:&lt;/p&gt;

&lt;p&gt;“When enabling the bridge mode, both master and slave can be active at the same time, each 
with its specific IO pins. Refer to the device datasheet to see which actual I/O port is 
used as alternative port selection for the slave in bridge mode.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Following this we have to use Port D as TWI slave and PORT C as TWI master.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So the setup look like the following:
&lt;code&gt;conf_board.h&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; //Part of conf_board.h
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; // TWIM for BMP180
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; #define TWI_MASTER       TWIC
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; #define TWI_MASTER_PORT  PORTC
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; #define TWI_MASTER_ADDR  0xEF
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; #define TWI_SPEED        1000000
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; 	 
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; // TWIS for XBUS
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; #define TWI_SLAVE        TWIC
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; #define TWI_SLAVE_PORT  PORTD&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;conf_twim.h&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; #define CONF_TWIM_INTLVL        TWI_MASTER_INTLVL_MED_gc
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; #define CONF_PMIC_INTLVL        PMIC_MEDLVLEN_bm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In the sensor coding, the TWI initialization code is in the &lt;code&gt;spektel.c&lt;/code&gt; file:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; bool spektel_init() { //TWI_t *twis) {
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; // Initialize ports
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; TWI_MASTER_PORT.PIN0CTRL = PORT_OPC_WIREDAND_gc;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; TWI_MASTER_PORT.PIN1CTRL = PORT_OPC_WIREDAND_gc;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; irq_initialize_vectors();
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; sysclk_enable_peripheral_clock(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; twi_bridge_enable(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; //twi_fast_mode_enable(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; //twi_slave_fast_mode_enable(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_SLAVE);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; twi_options_t m_options = {
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 	.speed     = TWI_SPEED,
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 	.chip      = TWI_MASTER_ADDR,
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 	.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), TWI_SPEED)
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As you can see the bridge mode works without the fast modes.&lt;/p&gt;

&lt;p&gt;Make sure you call &lt;code&gt;sysclk_init();&lt;/code&gt; at the beginning of your code and change &lt;code&gt;conf_clock.h&lt;/code&gt;
to the desired clock speed.&lt;/p&gt;

&lt;p&gt;Initializing the master:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; status_code = twi_master_init(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_MASTER, &lt;span class=&quot;ni&quot;&gt;&amp;amp;m_options);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; if(status_code != STATUS_OK) printf(&amp;quot;spektel_init.twi_master_init status: %x&amp;quot;, status_code);
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; twi_master_enable(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;twi-x-bus-slave-initialization&quot;&gt;TWI X-Bus slave initialization&lt;/h3&gt;
&lt;p&gt;We need to calculate the TWI slave address, the XMEGA TWI hardware implementation
listens to. The TWI master always sends a 7-bit slave address to address one slave 
listening on the bus. There is a register for this address, but in our case the sensor
should behave like a multiple personality and react to three sensor addresses.&lt;/p&gt;

&lt;p&gt;As muknukem (am rcgroups.com and rc-heli.de forums member) re-engineered, the Spektrum RC
X-Bus starts to enumerates the sensor addresses 70ms after the power is stable. It sends a 
request for each address between 0x01 to 0x7D, with pauses of 13ms in two cycles. Each
sensor the Spektrum transmitters know have one or more (the GPS sensor uses two, because
it needs to send more data) addresses. So the number of different sensors is theoretically
limited by the number of the requested addresses. On the other hand all is fixed and simple.  &lt;/p&gt;

&lt;p&gt;The good thing is, the TM1000 telemetry module doesn’t care, if the sensor reacts to a request for
lets say address 0x01 with 0x0A for the Powerbox sensor. It uses what the sensor sends back.
After the startup procedure, the TM1000 only asks for sensors we sent a response for
(again, the address sent back is the interesting one).&lt;/p&gt;

&lt;p&gt;The XMEGA reacts to all addresses by setting this register:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; TWIC.SLAVE.CTRLA |= 0x02; // PMEN: Promiscuous Mode Enable - address match logic disabled, react to everything&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But to save the interrupt routines some work it could be useful to set the XMEGA hardware
to react not to all. On the ATMEGA and Arduinos the following code works:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; uint8_t twi_slave_address = 0x00;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; status_code_t status_code = 0x00;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; // calculate slave address for single sensor (two TWI addresses are only support by XMEGA)
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; if( CURRENT_TEL ) {
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 	twi_slave_address |= CURRENT_SENS;
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; if( POWERBOX_TEL ) {
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 	twi_slave_address |= POWERBOX_SENS;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; if( VARIO_TEL ) {
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 	twi_slave_address |= VARIO_SENS;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;In my experience, this is not working for the XMEGA!&lt;/em&gt; And two addresses can be applied with
respect to the datasheet, but not three.&lt;/p&gt;

&lt;p&gt;So the further code looks like this:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; sysclk_enable_peripheral_clock(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_SLAVE);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; TWI_SlaveInitializeDriver(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;slave, &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_SLAVE, *slave_process);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where &lt;code&gt;*slave_process&lt;/code&gt; is a pointer to the a function reacting on requests from the master.
I will get into more detail later on.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; TWI_SlaveInitializeModule(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;slave, twi_slave_address, TWI_SLAVE_INTLVL_MED_gc);
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; //TWI address for Current, Powerbox and Vario and flight pack capacity
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; TWIC.SLAVE.ADDRMASK = (0x7F &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; 1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;which&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;different&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;used&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;sensors&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;TWIS_SEND_BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; 	&lt;span class=&quot;na&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;receivedData&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The magic is done by  writing  0x7F to the upper 7bits of the Slave ADDRMASK Address Mask Register.
The datasheet says:&lt;/p&gt;

&lt;p&gt;“If ADDREN is set to zero, ADDRMASK can be loaded with a 7-bit slave address mask. Each bit in ADDRMASK
can mask (disable) the corresponding address bit in the ADDR register. If the mask bit is one, the address match
between the incoming address bit and the corresponding bit in ADDR is ignored; i.e., masked bits will always
match.”&lt;/p&gt;

&lt;p&gt;We leave ADDREN (Bit 0 of the same register) to zero. The mask is calculated as following:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; 0000 0011	Current Sensor address
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 0000 1010	Powerbox Sensor address
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 0100 0000   Vario Sensor address
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 0011 0100   Flight Pack Capacity Sensor address
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; -----------------------------------
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 0111 1111   = 0x7F as Address Mask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; With the new Flight Pack Capacity Sensor and the used combination of sensors, the
method here is of no use. This will react to every address and be the same as the
&lt;code&gt;Promiscuous Mode&lt;/code&gt; described above. I leave it in for explanation and change options.&lt;/p&gt;

&lt;p&gt;The last part of the code initializes the receive buffer.&lt;/p&gt;

&lt;h3 id=&quot;twi-slave-operation&quot;&gt;TWI slave operation&lt;/h3&gt;
&lt;p&gt;Whenever the master request some data from the slave an interrupt routine within the ASF
is called and will ask some client code for the sensor values. And here is the first odd
part of the ASF TWI implementation in my humble opinion. The following was posted on avrfreaks.net
from me.&lt;/p&gt;

&lt;p&gt;When looking on the twis.c implementation for TWI slaves it misses an important functionality
to me. Looking at the Arduino Wire library it provides a &lt;code&gt;onReceive()&lt;/code&gt; and &lt;code&gt;onRequest()&lt;/code&gt; 
where the first one is to receive data from the master and the second is to respond to 
the masters request.When looking into the ASF TWI slave implementation there is only one 
callback for the &lt;code&gt;onReceive()&lt;/code&gt; case. So I didn’t figure out what the way to handle master 
requests would be. By initializing the TWI slave module the following is used (same as above):&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; sysclk_enable_peripheral_clock(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_SLAVE);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; TWI_SlaveInitializeDriver(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;slave, &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_SLAVE, *slave_process);
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; TWI_SlaveInitializeModule(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;slave, twi_slave_address, TWI_SLAVE_INTLVL_MED_gc);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Where &lt;code&gt;*slave_process&lt;/code&gt; is the callback. Looking in &lt;code&gt;twis.c&lt;/code&gt; it looks like the following. 
&lt;code&gt;TWI_SlaveDataHandler(...)&lt;/code&gt; is called (via two functions calls) in the TWIx Interrupt 
Service Routine.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; void TWI_SlaveDataHandler(TWI_Slave_t *twi)
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; 	if (twi-&amp;gt;interface-&amp;gt;SLAVE.STATUS &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt; TWI_SLAVE_DIR_bm) {
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; 		TWI_SlaveWriteHandler(twi);
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; 	} else {
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 		TWI_SlaveReadHandler(twi);
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; //and later
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; /* brief TWI slave read interrupt handler.
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt;  *  Handles TWI slave read transactions and responses.
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt;  *  param twi The TWI_Slave_t struct instance.
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; void TWI_SlaveReadHandler(TWI_Slave_t *twi)
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 	/* Enable stop interrupt. */
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; 	uint8_t currentCtrlA = twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLA;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 	twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; 	/* If free space in buffer. */
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; 	if (twi-&amp;gt;bytesReceived &lt;span class=&quot;nt&quot;&gt;&amp;lt; TWIS_RECEIVE_BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 		&lt;span class=&quot;err&quot;&gt;/*&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Fetch&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; 		&lt;span class=&quot;na&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;twi-&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;interface-&amp;gt;SLAVE.DATA;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; 		twi-&amp;gt;receivedData[twi-&amp;gt;bytesReceived] = data;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; // look here &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; 		/* Process data. */
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 		twi-&amp;gt;Process_Data();
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 		twi-&amp;gt;bytesReceived++;
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 		/* If application signalling need to abort (error occured),
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 		 * complete transaction and wait for next START. Otherwise
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 		 * send ACK and wait for data interrupt.
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; 		 */
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 		if (twi-&amp;gt;abort) {
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; 			twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; 			twi-&amp;gt;abort = false;
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; 		} else {
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; 			twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
&lt;span class=&quot;lineno&quot;&gt;44&lt;/span&gt; 		}
&lt;span class=&quot;lineno&quot;&gt;45&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;46&lt;/span&gt; 	/* If buffer overflow, send NACK and wait for next START. Set
&lt;span class=&quot;lineno&quot;&gt;47&lt;/span&gt; 	 * result buffer overflow.
&lt;span class=&quot;lineno&quot;&gt;48&lt;/span&gt; 	 */
&lt;span class=&quot;lineno&quot;&gt;49&lt;/span&gt; 	else {
&lt;span class=&quot;lineno&quot;&gt;50&lt;/span&gt; 		twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
&lt;span class=&quot;lineno&quot;&gt;51&lt;/span&gt; 		                              TWI_SLAVE_CMD_COMPTRANS_gc;
&lt;span class=&quot;lineno&quot;&gt;52&lt;/span&gt; 		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
&lt;span class=&quot;lineno&quot;&gt;53&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;54&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So you see, that for the read handler the Process_Data callback handler is placed. Looking
on the write handler this callback is missing. The following change of &lt;code&gt;twis.c&lt;/code&gt; works 
for me (I only need the onRequest() so I used the same callback function):&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; /* brief TWI slave write interrupt handler.
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;  *  Handles TWI slave write transactions and responses.
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;  *  param twi The TWI_Slave_t struct instance.
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 	/* If NACK, slave write transaction finished. */
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 	if ((twi-&amp;gt;bytesSent &amp;gt; 0) &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (twi-&amp;gt;interface-&amp;gt;SLAVE.STATUS &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	                             TWI_SLAVE_RXACK_bm)) {						 
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 		twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; //&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; added the next line for callback		
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 		twi-&amp;gt;Process_Data();
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 	/* If ACK, master expects more data. */
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 	else {
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; 		if (twi-&amp;gt;bytesSent &lt;span class=&quot;nt&quot;&gt;&amp;lt; TWIS_SEND_BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 			&lt;span class=&quot;na&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;twi-&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;sendData[twi-&amp;gt;bytesSent];
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 			twi-&amp;gt;interface-&amp;gt;SLAVE.DATA = data;
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; 			twi-&amp;gt;bytesSent++;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 			/* Send data, wait for data interrupt. */
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; 			twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; 		}
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt; 		/* If buffer overflow. */
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; 		else {
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; 			twi-&amp;gt;interface-&amp;gt;SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 		}
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 	}
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I don’t think such changes should be made to a standard library. But I invested to much time
to understand the framework, so that it was easier for me than a rewrite.&lt;/p&gt;

&lt;h3 id=&quot;sending-out-data&quot;&gt;Sending out data&lt;/h3&gt;
&lt;p&gt;If the slave_process function is called via the &lt;code&gt;twi-&amp;gt;Process_Data()&lt;/code&gt; function pointer,
&lt;code&gt;spektel_write_sensor_data()&lt;/code&gt; is called sending out the data in a round robin pattern.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; /**
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;  * \brief Write the values of a sensor to the (I2C/TWI) X-Bus. Since the TM1000 doesn&amp;#39;t match
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;  *        the requested address to the delivered address this function implements a round robin.	
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; void spektel_write_sensor_data() {
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; 	uint8_t i = 0;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; 	if(slave.status == TWIS_STATUS_READY) {
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; 		for(i = 0; i &lt;span class=&quot;nt&quot;&gt;&amp;lt; DATA_LENGTH&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;TWIS_SEND_BUFFER_SIZE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 			&lt;span class=&quot;na&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toggle =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 				&lt;span class=&quot;na&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;powerbox_data&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 			&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toggle =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 				&lt;span class=&quot;na&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;current_data&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 			&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toggle =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 				&lt;span class=&quot;na&quot;&gt;slave&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;vario_data&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 			&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 		&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 	&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 	&lt;span class=&quot;na&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toggle&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 2) toggle = 0;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;All we need to do is to write the data to the &lt;code&gt;slave.sendData[]&lt;/code&gt; array. Since each X-Bus
data package is 16 byte long starting with the slave address in the first byte, a zero byte
and then the data, we can send all data in one chunk. I just changed the buffer sizes in the
&lt;code&gt;twis.h&lt;/code&gt; file to 16 byte:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; /* Buffer size defines. */
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; #define TWIS_RECEIVE_BUFFER_SIZE         16
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; #define TWIS_SEND_BUFFER_SIZE            16&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The format of each sensor data package is defined by the Spektrum TM1000 module and translated
to data structures in the &lt;code&gt;spektel.h&lt;/code&gt; file. If the measuring code of the sensor has new data,
it writes it to these structures (for example &lt;code&gt;spektel_sensor_powerbox_t&lt;/code&gt;) and calls the 
&lt;code&gt;spektel_write_pwerbox_sens(...)&lt;/code&gt; function which translates it into an 16 byte array for the
next TWI &lt;code&gt;onRequest()&lt;/code&gt; action.&lt;/p&gt;

&lt;p&gt;I hope the whole process on the slave side gets clear now.&lt;/p&gt;

&lt;h3 id=&quot;communication-as-a-twi-master&quot;&gt;Communication as a TWI Master&lt;/h3&gt;
&lt;p&gt;Setting up the connection to the BMP180, where the XMEGA is the Master and the BMP180 is the
slave took me some time to figure out. But one by one!&lt;/p&gt;

&lt;h3 id=&quot;getting-the-hardware-right&quot;&gt;Getting the hardware right&lt;/h3&gt;
&lt;p&gt;The I2C / TWI bus used to connect the Bosch BMP180 pressure sensor has two pull-up resistors.
This is the general design of each TWI bus and used on the X-Bus TM1000 side as well. One
resistor for each line (SDA/SCL) no matter how many slaves are connected to pull the open drain
signal lines to Vcc (3.3V in our case) if needed. If you work with a 5V µC you will need
an additional level shifter.&lt;/p&gt;

&lt;p&gt;I tried to be smarter than the datasheet and put 2.7K in. It turned out, that they are two
small to drive the SDA and SCL lines to GND fast enough. So use 4.7K for the TWI/I2Cs instead.
For the X-Bus 2.7K seems to work, but the connection using a 20cm cable is much longer as the
1cm data lines on the board for the BMP180.&lt;/p&gt;

&lt;p&gt;I got myself a Saleae Logic8 logic analyser. Why it is probably not the most needed tool,
in this case it helps a lot. And it brings analog monitoring functionality as well. From the
signal shape below I figured out that something goes wrong. The XMEGA trys to pull down the 
signal resulting in a slow drop of the signal voltage.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/saleae_logic_i2c_bmp180_faulty.jpg&quot; /&gt;
	&lt;figcaption&gt;Monitoring the I2C bus to the BMP180&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;It has to look this way. The sequence just reads the static device ID for test purposes.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/saleae_logic_i2c_bmp180.jpg&quot; /&gt;
	&lt;figcaption&gt;Monitoring the I2C bus to the BMP180&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;initializing-the-master&quot;&gt;Initializing the Master&lt;/h3&gt;
&lt;p&gt;Here the code from the TWI initialization routine above again in short form: &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; bool spektel_init() {
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt; // Initialize ports
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt; TWI_MASTER_PORT.PIN0CTRL = PORT_OPC_WIREDAND_gc;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt; TWI_MASTER_PORT.PIN1CTRL = PORT_OPC_WIREDAND_gc;
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt; irq_initialize_vectors();
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt; sysclk_enable_peripheral_clock(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt; twi_bridge_enable(&lt;span class=&quot;ni&quot;&gt;&amp;amp;TWI_MASTER);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; twi_options_t m_options = {
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; 	.speed     = TWI_SPEED,
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	.chip      = TWI_MASTER_ADDR,
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 	.speed_reg = TWI_BAUD(sysclk_get_cpu_hz(), TWI_SPEED)
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now we can directly start writing to the slave devices. In our case, the BMP180
provides EEPROM style registers for the communication. So this is a standard style
for TWI communication.&lt;/p&gt;

&lt;p&gt;Write: Write the 7-bit slave address and the LSB (most right bit) bit 1 for read and 0 for 
write. As it turns out this was the next pitfall the ASF provides for me. In all of the 
Atmel code, I worked with the 7-bit slave address more or less like with an 8-bit address 
(expect for direct access to the registers). But the ASF library functions 
&lt;code&gt;twi_master_write&lt;/code&gt;and &lt;code&gt;twi_master_read&lt;/code&gt; add the LSB dependent on the read or write function.
I guess this is part of the TWI-EEPROM access protocol. Where the Bosch datasheet talks
about 0xEF for read and 0xEE for write, the ASF functions need 0x77! With this we can read 
and write bytes:&lt;/p&gt;

&lt;p&gt;Here the code from the TWI initialization routine above again in short form: &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; /** Read a byte
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;  * \param reg_addr the register address.
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;  * \param byte the data to be read.
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;  * \return status of read operation
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; static uint8_t read_byte(const uint8_t reg_addr, uint8_t *byte)
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	twi_package_t r_packet = {
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 		.addr		 = { reg_addr },
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 		.addr_length = 1,
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 		.chip        = BMP180_ADDR_READ &amp;gt;&amp;gt; 1,
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 		.buffer      = byte,
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 		.length      = 1,
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 		.no_wait     = false
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 	};
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 	return twi_master_read(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_MASTER, &lt;span class=&quot;ni&quot;&gt;&amp;amp;r_packet);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; }
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; /** Write a byte
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;  * \param reg_addr the register address.
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt;  * \param byte the data to be written.
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt;  * \return status of operation
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt; static uint8_t write_byte(const uint8_t reg_addr, uint8_t byte)
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt; 	twi_package_t w_packet = {
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt; 		.addr		 = { reg_addr },
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt; 		.addr_length = sizeof(reg_addr),
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt; 		.chip        = BMP180_ADDR_WRITE &amp;gt;&amp;gt; 1,
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt; 		.buffer      = &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;byte,
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt; 		.length      = sizeof(uint8_t),
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt; 		.no_wait     = false
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt; 	};
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; 	return twi_master_write(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_MASTER, &lt;span class=&quot;ni&quot;&gt;&amp;amp;w_packet);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For the .chip you can use 0x77 or the datasheet address shifted to the right. On the bus
the XMEGA will call with 0xEF and 0XEF showing if it wants to read or write. &lt;/p&gt;

&lt;h3 id=&quot;reading-many-bytes&quot;&gt;Reading many bytes&lt;/h3&gt;
&lt;p&gt;Another pitfall was, that the Atmel ASF seems to expect the MSB (in this case higher &lt;strong&gt;byte&lt;/strong&gt; 
of a 16 bit value) and LSB (lower byte) order different than the Bosch BMP180. The 
library supports to read multiple bytes in one read. Doing so, the BMP180 respondes with 
the MSB, the Master sends an &lt;code&gt;ACK&lt;/code&gt; requesting more data. Then the BMP180 sends the LSB
and a &lt;code&gt;NAK&lt;/code&gt; follows to finish the communication and release the bus.
But the ASF gives back that values in the wrong order LSB-MSB. So a swap operation is needed
at the end. Either the BMP180 or the ASF gets it wrong!?  &lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; /** Read word (16bit)
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;  * \param reg_addr the register address.
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;  * \param word the data to be read.
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;  *
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;  * \return status of operation
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;  */
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt; static uint8_t read_word(const uint8_t reg_addr, uint16_t *word)
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt; {
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt; 	uint8_t err;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt; 	twi_package_t r_packet = {
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; 		.addr		 = { reg_addr },
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 		.addr_length = sizeof(reg_addr),
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; 		.chip        = BMP180_ADDR_READ &amp;gt;&amp;gt; 1,
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt; 		.buffer      = word,
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt; 		.length      = sizeof(uint16_t),
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt; 		.no_wait     = false
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt; 	};
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt; 	err = twi_master_read(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TWI_MASTER, &lt;span class=&quot;ni&quot;&gt;&amp;amp;r_packet);&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt; 	uint8_t lsb = (*word) &amp;gt;&amp;gt; 8;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt; 	(*word) = ((*word) &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; 8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lsb&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; 	&lt;span class=&quot;na&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/XMEGA_ASF_TWI&quot;&gt;XMEGA, ASF and TWI/I2C&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on January 03, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Sensor setup]]></title>
  <link rel="alternate" type="text/html" href="/articles/Sensor_setup" />
  <id>/articles/Sensor_setup</id>
  <published>2014-12-31T00:00:00+01:00</published>
  <updated>2014-12-31T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;The sensor firmware can be used with different configurations. Basically the firmeware should
be able to support different revisions of the sensor, several assembly options and be configurable
to different models and flight situations.&lt;/p&gt;

&lt;h3 id=&quot;assembly-options&quot;&gt;Assembly options&lt;/h3&gt;

&lt;p&gt;REV_B as the actual sensor can be assembled with different component options. The 
&lt;code&gt;Allegro ACS758LCB-100U-PFF-T&lt;/code&gt; is as well available in a 50A and 200A version. 
This indicates the maximum measurement range of the hall sensor, while
it can take a current many times higher without damage. But using the 50A version
will give double the precision than the 100A version.&lt;/p&gt;

&lt;p&gt;By changing the resistors (R7 and R8) of the voltage divider for the voltage measurement,
batteries with more than 6 cells can be supported as well as higher precision for less cells
can be enabled.&lt;/p&gt;

&lt;p&gt;Another option is to omit the &lt;code&gt;Bosch BMP180&lt;/code&gt; pressure sensor, if the altimeter and vario
functions are not needed. Unused connectors can be cut out as well.&lt;/p&gt;

&lt;h3 id=&quot;firmeware-setup&quot;&gt;Firmeware setup&lt;/h3&gt;
&lt;p&gt;One basic requirement is to setup the capacity of the used battery for the alarm.&lt;/p&gt;

&lt;p&gt;While it is no problem to setup the sensor using the development environment, a target of
the project was to provide setup methods not requiring a development environment. The
hardware offers two general possibilities. One option is to use the &lt;code&gt;Serial port&lt;/code&gt; via a
Serial-USB adaptor or a PC independent setup box. The second is to use the build
in button. The latter method can only provide basic setup functions.&lt;/p&gt;

&lt;h3 id=&quot;setup-parameters&quot;&gt;Setup parameters&lt;/h3&gt;
&lt;p&gt;Here is a list of useful setup parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Capacity of the sensor in mAh&lt;/li&gt;
  &lt;li&gt;Alarm threshold at a minimum capacity (in mAh) or as a percentage left of the max capacity (in %)&lt;/li&gt;
  &lt;li&gt;An optional second alarm threshold for the capacity (as the Powerbox sensor has two capacity alarms&lt;/li&gt;
  &lt;li&gt;A voltage threshold for the main battery voltage (in mV) or,&lt;/li&gt;
  &lt;li&gt;The number of cells used and a calculated minimum voltage of the pack&lt;/li&gt;
  &lt;li&gt;The hight of the airfield (in m), useful, if the flight can go below the airfield (in the mountains)&lt;/li&gt;
  &lt;li&gt;Several calibration parameters to adjust the sensor to the used components&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;setup-on-the-airfield&quot;&gt;Setup on the airfield&lt;/h3&gt;
&lt;p&gt;The setup method for the airfield using the sensors button, allows only for setting up
the &lt;strong&gt;Capacity of the battery in mAh&lt;/strong&gt;. The alarm (Cap1 alarm) will be activated, if the 
calculated capacity falls under 20% of this value.&lt;/p&gt;

&lt;p&gt;For the setup start the transmitter with the model setup bound to the receiver used and the
Powerbox telemetry sensor activated. Now hold the button on the bottom side (backside of 
the XMEGA) pressed while powering the sensor. Note that the power for the sensor comes 
via the X-Bus, TM1000 and receiver from the receiver battery or BEC. The sensor will 
indicate the setup mode by blinking three times both LEDs. Release the button after the
first blinking of both LEDs.&lt;/p&gt;

&lt;p&gt;Now the Cap1 display will count up by one hundred each second starting by zero again. If
the desired number is displayed press the button until the red LED goes out. Now the display
will loop through the thousands digit from 0 to 9. If the right number is displayed press the
button until the red LED lights up again. Now the same process starts for the ten thousands
digit, but only from 0 to 5. Press the button until the red LED lights up.&lt;/p&gt;

&lt;p&gt;If the value is saved successfully to the EEPROM, the red LED goes out again. The sensor
can be used right away and will reload the stored capacity value on the next power up.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To stop the setup process in between, cut the power of the sensor!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;self-calibration&quot;&gt;Self calibration&lt;/h3&gt;
&lt;p&gt;Since the ACS758 hall sensor and ADC have some tolerance, as well as the used resistors a
calibration procedure is required. After the setup procedure, the sensor will do a self
calibration. Please make sure, that nothing is connected to the battery cables. The sensor 
will get it’s power via the X-Bus from the TM1000 module. The calibration values are
stored to the EEPROM as well.&lt;/p&gt;

&lt;h3 id=&quot;restrictions&quot;&gt;Restrictions&lt;/h3&gt;
&lt;p&gt;I implemented the setup function using a simple way. There are no interrupts, no debounce
of the button, etc. So you need to watch to the LED and release the button after the
red light changes. But hey, it is only the setup function, you won’t use it every day.&lt;/p&gt;

&lt;p&gt;Since the capacity in the Spektrum X-Bus protocol uses a 16Bit
variable, the maximum is 65535mAh. For program simplicity the maximum battery capacity
is now limited to 59.900mAh, which should be good enough for most RC use cases.&lt;/p&gt;

&lt;h3 id=&quot;hook-up-diagramm&quot;&gt;Hook up diagramm&lt;/h3&gt;
&lt;p&gt;Since I have not given a hook up guide, I will provide a small sketch to see the basic
installation. To measure the main battery voltage, there needs to be a ground connection
between the sensor and the main battery negative pole. This is normally given by the BEC
system in the electronic speed controller. If not you need to wire an additional connection.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/hook_up_diagram_REV_B.png&quot; /&gt;
	&lt;figcaption&gt;Hook up diagram&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;outlook&quot;&gt;Outlook&lt;/h3&gt;
&lt;p&gt;The serial port was intended to provide more sophisticated options for setting up
the sensor. Using a terminal program and a kind of AT commands this can be easily achieved.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/articles/Sensor_setup&quot;&gt;Sensor setup&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on December 31, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Firmware Part 1]]></title>
  <link rel="alternate" type="text/html" href="/articles/Software_part_1" />
  <id>/articles/Software_part_1</id>
  <published>2014-12-23T00:00:00+01:00</published>
  <updated>2014-12-23T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;After the board is assembled and working it is time to move to the software part. As
mentioned earlier, most of the magic is in the code. This post is intended to help to
understand the source code of the sensor firmware.&lt;/p&gt;

&lt;p&gt;This is not a C or Atmel Studio tutorial. It will suite programmers, who know basic C (or
C style programming) and move to the XMEGA development. Although the Atmel datasheet is our
friend and the basis of the code I will not go into the XMEGA details. I’m just not expert 
enough up to now to do so.&lt;/p&gt;

&lt;p&gt;Download the XMEGA datasheet and manual from the &lt;a href=&quot;http://www.atmel.com&quot;&gt;Atmel&lt;/a&gt; website. 
The datasheet covers the specialities of the &lt;code&gt;ATXMEGA32E5&lt;/code&gt; while the manual is the same
for all XMEGAs and provides a deep look in each hardware module.&lt;/p&gt;

&lt;h3 id=&quot;testing-the-board&quot;&gt;Testing the board&lt;/h3&gt;
&lt;p&gt;The “Hello world!” in the µC world is a blink. The board has two LEDs to do some blinking
and see if the code uploads without problem. Whenever you get stuck it’s time to reassure
the basic functions. A Todo would be to provide some basic testing code. Maybe by pressing
the button, the sensor can run some test, blink the LEDs, send some test data to the transmitter.&lt;/p&gt;

&lt;h3 id=&quot;development-process&quot;&gt;Development process&lt;/h3&gt;
&lt;p&gt;I use the Atmel studio 6 with the ASF framework. The ASF wizard helps to specify the
required libraries based on the cpu modules and functions you want to use. By setting up 
the right device (the ATXMEGA32E5) and a custom board it selects the correct pin and register
definitions.
After writing the code, it needs to be compiled in an .elf file containing the machine code.
Using the programming tool in AVR Studio the flash memory gets erased and rewritten. The
µC resets and starts to run the new code.&lt;/p&gt;

&lt;p&gt;A debugger seems very useful, but I didn’t use it much. In most environments a debugger
affects the runtime, at least it corrupts the timing. I don’t know the effects for
XMEGA debugging at the moment.&lt;/p&gt;

&lt;h3 id=&quot;basic-architecture-of-the-firmware&quot;&gt;Basic architecture of the firmware&lt;/h3&gt;
&lt;p&gt;The software consist of three main blocks:&lt;/p&gt;

&lt;p&gt;A.) The classic &lt;code&gt;while(1){...}&lt;/code&gt; in the &lt;code&gt;main()&lt;/code&gt; function doing most of the calculation. After
entering the infinit while loop the &lt;code&gt;sleepmanager&lt;/code&gt;is called and goes to sleep, until it
gets a wake up call by block B (an additional global variable is used to assure only block B
can trigger main measurement). The calculated measurements are written to block C.&lt;/p&gt;

&lt;p&gt;B.) A timer to trigger the main ADC measuring the current using the Allegro hall sensor.
The ADC is coupled to the timer by the event system. After the measurement is finished, an
interrupt is fired reading the result und waking up block A from the sleep mode.&lt;/p&gt;

&lt;p&gt;C.) This block serves the X-Bus requests from the Spektrum TM1000 telemetry module. This
block is triggered by a TWI/I2C interrupt and just uses the values provided by block B 
and transmits them to the telemetry module.&lt;/p&gt;

&lt;p&gt;So we have two interrupt sources, the main measurement timer and the X-Bus interrupts. The
first triggers the measurements and calculations. The X-Bus trigger grabs the data and
sends it out. Now we go through the programm flow starting with the timer trigger of block
B. &lt;/p&gt;

&lt;h3 id=&quot;triggered-by-a-timer&quot;&gt;Triggered by a timer&lt;/h3&gt;
&lt;p&gt;A timer is a module, which can fire events after a defined number of clock cycle counts 
or when the counter register gets an overflow. The XMEGA can be clocked up to 32MHz, this
are 32 million counts per second, if not using any prescaler. A prescaler can divide the
clock rate by a binary factor (2,4,8,16, etc.) for longer intervals. By counting the 
overflows in a second register timers can be used for longer times, than the overflow time.&lt;/p&gt;

&lt;p&gt;The basic trigger of the sensor is a timer at 25 or 50Hz firing an event every 40 or 20ms.
Both settings work without problems. To get the right time, many parameters needs to be
considered. If the time is to long, the measurement may be to rough for a good capacity
calculation. If the time is to short, the ADC measurement and calculations may be interrupted
by the next cycle. ADCs need some time for precise results. The &lt;code&gt;tc_init()&lt;/code&gt; function
initializes the timer with 3 interrupts. The &lt;code&gt;error_interrupt&lt;/code&gt; catches errors in the timer
system and lights the red LED. the &lt;code&gt;overflow_interrupt&lt;/code&gt; restarts the timer. The &lt;code&gt;cca_interrupt&lt;/code&gt;
is the one we are interested in this case. It is set to fire at half the timer period. Maybe
for clarity I could have changed the code to just use the &lt;code&gt;overflow_interrupt&lt;/code&gt;. This would
have the same effect in this case. &lt;/p&gt;

&lt;p&gt;The timer event is used to trigger the event system. By using the event system of the XMEGA
events like the start of an ADC measurement can be started. So more than one event can be
triggered by one interrupt and it gives additional flexibility. It’s not necessary in this
code, but I used it nevertheless. The following lines configure the event system:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; EVSYS.CH3MUX = EVSYS_CHMUX_TCC4_CCA_gc;  //Connect TCC4 Compare interrupt to event channel 3 (used to trigger ADC)
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; tc45_set_resolution(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;TIMER_SENS, TIMER_SENS_RESOLUTION);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt;, that several config files, typically named &lt;code&gt;conf/&amp;lt;modulname&amp;gt;_config.h&lt;/code&gt; are used
to parameterize the modules on startup. These are used by the modules init functions.&lt;/p&gt;

&lt;h3 id=&quot;analog-digital-converter&quot;&gt;Analog-Digital-Converter&lt;/h3&gt;
&lt;p&gt;The heart of the sensor is the Allegro hall sensor converting a current up to 100 Amps (or
even up to 200A with another version) to an almost linear voltage and the XMEGA analog to
digital converter. The XMEGA ADC can convert a voltage range between GND and around 2V to
a 12Bit value in single-ended unsigned mode. This will be reduced by using a signed mode
(for negative voltages) or an external voltage reverence. Using the 12Bit the least 
significant bit represents 0.4899mV.&lt;/p&gt;

&lt;p&gt;The Allegro outputs 396 to 410 mV by 0mA current up to nearly 3.1V at 100A. So we have 
to transfer this range to the max of 2.048V of the external voltage reference or the internal
voltage reference of Vcc/1.6 = 2.063V. This is done by a voltage divider of 3K to 4.7K Ohm.&lt;/p&gt;

&lt;p&gt;The ADC gets initialized in &lt;code&gt;adc_init()&lt;/code&gt;. There is the ADC port and an ADC channel. The used
XMEGA has only one ADC port and one channel. Multiple channels would allow for parallel
measurements. This would have been nice for measuring the current and voltage simultaneously.&lt;/p&gt;

&lt;p&gt;Setting up the ADC:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adc_set_conversion_parameters(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adc_conf, ADC_SIGN_OFF,ADC_RES_MT12 , ADC_REF_VCC);  // ADC_RES_12&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Sets the unsigned mode with 12Bit resolution and the internal Vcc as VREF.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adc_set_conversion_trigger(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adc_conf, ADC_TRIG_EVENT_SYNCSWEEP,1, 3 );
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; adc_set_clock_rate(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adc_conf, ADC_CLOCK); // ADC clock 1.8MHz&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Sets the trigger to an event and specifies the ADC clock rate. Higher clock rates allow for
faster measurements, slower is more precise. I use a fast setting to be save.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adc_set_callback(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;ADC_MAIN, *adc_cur_callback);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Callback function called when the measurement is finished. The time of a measurement is 
calculated by the number of result bits (at least one clock cycle per bit) and some time 
to transfer the result to the result register.  &lt;/p&gt;

&lt;p&gt;To use different pins for ADC probes, the ADC channnel needs to be reconfigured. So there
are two functions to set up the channel. The &lt;code&gt;adcch_set_cur_measure()&lt;/code&gt; for current and
&lt;code&gt;adcch_set_volt_measure()&lt;/code&gt; for the main battery voltage measurement. The difference is, that
the current measurement works with an interrupt firing after the result is there, while
the voltage measurement gets started and then checked (blocking in a while loop) for the
result.&lt;/p&gt;

&lt;p&gt;Setting up the ADC channel:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adcch_set_input(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adcch_conf, ADC_MAIN_CURRENT_PIN, ADCCH_NEG_NONE, 1);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This sets the pin for measuring, the negative pin which is not used here and gain (not used here).&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adcch_enable_averaging(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adcch_conf, ADC_CUR_AVERAG_SAMP);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I enabled the averaging function of the XMEGA32E5 taking 4 samples and returning the average
of these.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; adcch_set_interrupt_mode(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;adcch_conf, ADCCH_MODE_COMPLETE); //complete conversion
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; adcch_enable_interrupt(&lt;span class=&quot;ni&quot;&gt;&amp;amp;adcch_conf);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Configures the channel interrupt to fire when the analog to digital conversion is completed.
The callback function is taken from the ADC setup.&lt;/p&gt;

&lt;p&gt;If the ADC conversion is completed, the callback function is called:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; static void adc_cur_callback(ADC_t *adc, uint8_t ch_mask, adc_result_t res) {
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; 	cur_mea_val = res;
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; 	act = !act;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; 	time[act] = rtc_get_time();
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; 	
&lt;span class=&quot;lineno&quot;&gt;6&lt;/span&gt; 	measure_cycle = true;	
&lt;span class=&quot;lineno&quot;&gt;7&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since this XMEGA provides only one channel, the channel mask parameter will alway be the same.
The result is saved to the &lt;code&gt;cur_mea_val&lt;/code&gt; global variable. Then the actual time is saved
to &lt;code&gt;time[act]&lt;/code&gt;. This is switched each measure cycle to have the actual and latest measurement
time for the capacity calculation. The measure_cycle = true is set to signalize the main
loop that a new result is available.&lt;/p&gt;

&lt;p&gt;I will cover the main calculations in the next part!&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/articles/Software_part_1&quot;&gt;Firmware Part 1&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on December 23, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Hardware assembly]]></title>
  <link rel="alternate" type="text/html" href="/articles/Hardware_assembly" />
  <id>/articles/Hardware_assembly</id>
  <published>2014-12-22T00:00:00+01:00</published>
  <updated>2014-12-22T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;After a while the REV_B PCBs arrived. So I instantly started to assemble the board. I will 
give you some insight in the process of the Surface Mount Technology (SMT) and tools I use.
Then there where some pitfalls and workarounds I will show. &lt;/p&gt;

&lt;h3 id=&quot;shrinking-the-board&quot;&gt;Shrinking the board&lt;/h3&gt;
&lt;p&gt;Remember, that I am still quite new to the surface mount devices. From REV_A to REV_B I 
changed all passive components from the 1206 to the 0603 package format. There are 
imperial (inch) and metric (mm) size form factors. Unfortunately the 0603 exists in both. In
inch it is 1.6mm long and 0.8mm wide. After some practice, I could handle this size, although the 
1206 inch size with its length of 3.2mm and width of 1.6mm is a bit easier to handle. By
mistake I ordered a few hundred metric 0603 (an imperial 0201) capacitors. These are 
0.6mm long and 0.3 mm wide. I guess it is nearly impossible to solder them reliable using
a solder iron. Find a overview on the sizes &lt;a href=&quot;http://http://en.wikipedia.org/wiki/Surface-mount_technology&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-tooling&quot;&gt;The tooling&lt;/h3&gt;
&lt;p&gt;I wanted to shrink the board and still use small and simple tools for the assembly. I don’t
have the room for a reflow oven and all that stuff.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Here is my basic toolset:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Good SMT tweezers (look for anti-magnetic, anti-static good quality)&lt;/li&gt;
  &lt;li&gt;Soldering iron with 0.8mm flat tip (I use a analog regulated 80W station)&lt;/li&gt;
  &lt;li&gt;Solder wick 1mm width&lt;/li&gt;
  &lt;li&gt;Leaded solder in 0.5mm diameter&lt;/li&gt;
  &lt;li&gt;Flux pen dispenser&lt;/li&gt;
  &lt;li&gt;Magnifying lens 15x&lt;/li&gt;
  &lt;li&gt;Clockmaker magnifying lens cap&lt;/li&gt;
  &lt;li&gt;0.4 mm tinned copper wire (mainly for the vias)&lt;/li&gt;
  &lt;li&gt;Wire cutter (not used for SMT)&lt;/li&gt;
  &lt;li&gt;Ohmmeter with connection tester&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/SMT_toolset.jpg&quot; /&gt;
	&lt;figcaption&gt;SMT Toolset&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;I wear the clockmaker magnifying lens with low magnification, because for soldering I don’t need
to see all the details. I flux the pads and tin one pad. The pad doesn’t need to be 
completely covered. Then I hold the SMD component with the tweezers and touch the component
pin and pad with the solder tip by putting the flat part on the pad. Because of the small
component and pad it takes only one to two seconds to see the solder flow. I use 320 to 400°C
for soldering. If one pad is a ground pad with a some connections to larger PCB areas it may
take a little longer to solder. Take your time, I didn’t burn a part up to now.&lt;/p&gt;

&lt;p&gt;Larger components like the XMEGA can be soldered the same way. Fix one pin, then another 
one on the oposite edge. After that the pins can be soldered one by one.&lt;/p&gt;

&lt;p&gt;Then I use the 15x magnifying lens with some light (holding the PCB against a lamp can help
as long as there are no big components mounted) to check for good solder and no unwanted shortcuts.
If there is a shortcut, don’t panic. Flux the area, put a fresh end of the solder wick on
the tinned part and the solder iron tip on top. The wick will soak up the solder.&lt;/p&gt;

&lt;p&gt;An Ohmmeter with a connection tester is a good companion. My multimeter has a mode, in 
which it will beep, if there is a connection. So I don’t need to look up to see if there is 
a wanted or unwanted connection. Test for the wanted connections and unwanted ones.&lt;/p&gt;

&lt;p&gt;After soldering the board I needed some time to find out unwanted connections like Ground
to Vcc and many more.&lt;/p&gt;

&lt;p&gt;A great tip I found very useful is to fix the SMD belts on a small board using double sided
duct tape. I wrote the values on the stripes. So everything is sorted and fixed.&lt;/p&gt;

&lt;h3 id=&quot;assembly-time&quot;&gt;Assembly time!&lt;/h3&gt;
&lt;p&gt;I ordered the board etched, tinned and drilled. So there are no connected vias and no 
solder or print masks. So first I removed all layers expect the routes, vias and components 
with their names in Eagle PCB to create a plan for assembling. You will find these assembly 
plans in the Github repository in the hardware REV_B folder. I printed these in A4 and 
marked the parts values by hand on it.&lt;/p&gt;

&lt;p&gt;The drill mask for the Allegro hall sensor big pins is incomplete. So I used a drill to
create the long holes needed. To connect the vias, I laid the board on a flat surface,
put 0.4mm tinned copper wire trough the holes and cut 2mm above. After 4 - 8 vias, I apply
flux and solder them. After all the other side can be soldered and the exzessive wire
cut away.&lt;/p&gt;

&lt;p&gt;Then I soldered the components on the top side (the µC side). I started with the small 
components inside out. Be aware, that diodes are polarized and get the direction right. 
The have a point or stripe on the minus pin. See the result on the next picture:&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/Assembled_REV_B_top.jpg&quot; /&gt;
	&lt;figcaption&gt;Assembled REV_B top side&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The Allegro current pins are not soldered yet.&lt;/p&gt;

&lt;p&gt;In the B revision I tried to avoid using pins as vias, since it is difficult to solder a 
pin header from its top. But it is necessary in two cases as shown in the errata later on.
The bottom side is much easier, because the two pin headers, two X-Bus connectors, the
Allegro sensor and button take almost all of the space.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/Assembled_REV_B_bottom.jpg&quot; /&gt;
	&lt;figcaption&gt;Assembled REV_B bottom side&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;assembling-the-bmp180&quot;&gt;Assembling the BMP180&lt;/h3&gt;
&lt;p&gt;The self created footprint of the BMP180 in Eagle is a little bit larger, so that there is
enough place for the soldering tip. Put solder on the connected pads. Be careful to get the 
pads filled, but don’t spend to much solder. Then flux, position the sensor - the pads are 
on the very edges - and heat while supplying little pressure with the tweezers. The BMP180
should level 100% with the board. Look from the side to see if it’s completely flat on
the board with no gap or seam. The metal case of the sensor must have a connection to ground. &lt;/p&gt;

&lt;h3 id=&quot;errata&quot;&gt;Errata&lt;/h3&gt;
&lt;p&gt;Again, there are some small faults on the board. Or at least things to optimize. I put
the connectors on the bottom side, so that most of the soldering can be made on the top side only.
The ground pin of the X-Bus ZH connectors needs to be connected to the bottom side.
At least the angled connector can be soldered more easy than the straight one. &lt;em&gt;Make sure
to solder this before assembling the straight connector&lt;/em&gt;. If you only use this sensor,
only one connector is needed anyway.&lt;/p&gt;

&lt;p&gt;Second, the ground pin of the Serial connector needs to be connected to the bottom plate.
I used an exacto knife to remove the plastic around the pin. With lots of flux the pin then
can be soldered.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/Assembled_REV_B_bottom_errata.jpg&quot; /&gt;
	&lt;figcaption&gt;Assembled REV_B bottom side&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;The I2C / TWI bus used to connect the Bosch BMP180 pressure sensor has two pull-up resistors.
I tried to be smarter than the datasheet and put 2.7K in. It turned out, that they are two
small to drive the SDA and SCL lines to GND fast enough. So use 4.7K for R4 and 
R5 instead.&lt;/p&gt;

&lt;p&gt;I got myself a Saleae Logic8 logic analyser. Why it is probably not the most needed tool,
in this case it helps a lot. And it brings analog monitoring functionality as well. From the
signal shape below I figured out that something goes wrong. The XMEGA trys to pull down the 
signal resulting in a slow drop of the signal voltage.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/saleae_logic_i2c_bmp180_faulty.jpg&quot; /&gt;
	&lt;figcaption&gt;Monitoring the I2C bus to the BMP180&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;It has to look this way. The sequence just reads the static device ID for test purposes.&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/saleae_logic_i2c_bmp180.jpg&quot; /&gt;
	&lt;figcaption&gt;Monitoring the I2C bus to the BMP180&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;outlook&quot;&gt;Outlook&lt;/h3&gt;
&lt;p&gt;In future versions, a small capacitor at the Allegro signal pin can serve as a hardware 
low pass filter (thanks to Ingo on the rc-heli.de forum). Additional cell voltage measurements
would be nice as well.  &lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/Hardware_assembly&quot;&gt;Hardware assembly&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on December 22, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[XMEGA32E5]]></title>
  <link rel="alternate" type="text/html" href="/articles/xmega" />
  <id>/articles/xmega</id>
  <published>2014-11-26T00:00:00+01:00</published>
  <updated>2014-11-26T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;Some may ask, why I have chosen the XMEGA32E5 for the project. Here is why, or at least
why at the end I used it.&lt;/p&gt;

&lt;h3 id=&quot;why-the-xmega&quot;&gt;Why the XMEGA?&lt;/h3&gt;
&lt;p&gt;Arduino is a great starting point for microcontroller beginners. Its widely available, 
has boards for easy assembling, a nice IDE and libraries for abstraction. And it’s all 
open source and low priced. So I started with the ATMEGA family going to straight 
AVR GCC programming using an ATTINY. Seeing Schorsch’s project on the RC-Heli 
&lt;a href=&quot;http://www.rc-heli.de/board/showthread.php?t=190165&quot;&gt;thread&lt;/a&gt; using the XMEGA with 
some features got my attention. The upgrade from the ATMEGA shouldn’t be that difficult.&lt;/p&gt;

&lt;h3 id=&quot;atmega-vs-xmega&quot;&gt;ATMEGA vs. XMEGA&lt;/h3&gt;
&lt;p&gt;The XMEGA32E5 comes in a small TQFP package. I was looking for a SMD package, since it 
reduces the overall project footprint. It brings a 12 Bit Analog-Digital-Converter 
and a event-system. There are two I2C ports, one as an I2C Slave and one as an I2C Master. 
The slave port is used for the connection to the Spektrum-RC, the master port for the BMP180 
pressure sensor. The XMEGA has a 32MHz clock rate compared to the 16MHz of the ATMEGA328.&lt;/p&gt;

&lt;p&gt;Being quite new to micros I didn’t expect much differences. 
But there are some. First, the XMEGA uses 3.3V and can not be operated using 5V. 
So all components should work with 3.3V too. Next the XMEGA uses PDI instead of ISP for 
programming the device. So I needed a dedicated programmer, since the Bootloader/USB 
method of the Arduino doesn’t work. I used the Arduino as an ISP for the ATTINY, which 
doesn’t work as well. Eventually I got a small cheap AVRISP clone based on an Atmel 
chip. But the Jungo USB drivers are not compatible to the Mac. So I switched to Windows, the 
Atmel AVR Studio and the ASF a development framework. To test this it is handy to have 
a XMEGA breakout board for testing.&lt;/p&gt;

&lt;h3 id=&quot;some-words-on-developing-on-mac-osx&quot;&gt;Some words on developing on Mac OsX&lt;/h3&gt;
&lt;p&gt;Using a Mac is no problem in most cases. A lot of Linux software is easily usable. There is
a AVR GCC toolchain and avrdude version at the Atmel website. Using a 
programmer with the FTDI USB chip (like the Arduinos use) is also no problem. 
But both, the cheap AVR ISP mkII clone as well as an Atmel JTAG ICE mkII didn’t work with
Mac OsX, since there is no Mac driver for the used Atmel USB chip. And I couldn’t get the
libusb running. At the end I switched to Windows 8.1 in a Parallels VM. With this I
use the AVR Studio 6.x. This is not that fast on my Mac Book Air (2010), but works.
I like the GCC toolchain, because it’s lightweight, but the AVR Studio is much more easy to use.&lt;/p&gt;

&lt;h3 id=&quot;using-the-atmel-avr-studio-and-asf&quot;&gt;Using the Atmel AVR Studio and ASF&lt;/h3&gt;
&lt;p&gt;The AVR Studio and ASF makes it easy to setup the device specific parts of a project.
Just select the microcontroller and modules (like ADC, Timer, etc.) used 
in the project, the programming tool and board if using a standard Atmel board.
The IDE and ASF takes care of including the required libraries and tools. 
The ASF works, but not always as expected. Maybe I will write on this later on.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The change from the ATMEGA to XMEGA was quite painful, since I changed the complete development
tool chain. This was the case, since I use a Mac and the programmer hardware does not supporte Mac OsX.&lt;/p&gt;

&lt;p&gt;Beside this it is quite different to program using Arduino, the Atmel AFS or pure C. I didn’t
test the XMEGA Arduino port, but I will keep using Arduino for fast prototyping with the
ATMEGA. At the moment I will stay with the AVR Studio and AFS for the more complex projects.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/xmega&quot;&gt;XMEGA32E5&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on November 26, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[New Revision_B board ready]]></title>
  <link rel="alternate" type="text/html" href="/articles/new_rev_b" />
  <id>/articles/new_rev_b</id>
  <published>2014-11-23T00:00:00+01:00</published>
  <updated>2014-11-23T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;The &lt;code&gt;REV_A&lt;/code&gt; sensor worked and the last capacity measurements were within 3% of the loaded capacity.
So thinks were working fine. But the REV_A board had a major bug on the footprint of the
BMP180 pressure sensor I want to use for the Vario and Altimeter functions. So I tried to 
fix it with the solder iron. At the end I bricked it. One of the PDI lines goes under the
microcontroller and this was the one having a short connection to the ground.&lt;/p&gt;

&lt;p&gt;Since I proved everything possible with &lt;code&gt;REV_A&lt;/code&gt; I went on and designed &lt;code&gt;REV_B&lt;/code&gt;. It’s on
&lt;a href=&quot;https://github.com/csc13/spektel-sensor/tree/master/hardware/REV_B&quot;&gt;GitHub&lt;/a&gt; right now.&lt;/p&gt;

&lt;h3 id=&quot;news-in-revb&quot;&gt;News in REV_B&lt;/h3&gt;

&lt;p&gt;There are some new features:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A button for programming&lt;/li&gt;
  &lt;li&gt;A voltage reverence of 2048mV to the AREF pin of the XMEGA&lt;/li&gt;
  &lt;li&gt;Some &lt;strong&gt;Ferrite Chip Beads&lt;/strong&gt; and some small capacities at the IC VCC pins for steady working power&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And it has a much smaller footprint of a board size under 35x35mm! So most components have
the 0603 SMD package. This will be a challenge for the soldering I plan to do by hand.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;/articles/new_rev_b&quot;&gt;New Revision_B board ready&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on November 23, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Adding Processing support]]></title>
  <link rel="alternate" type="text/html" href="/articles/Adding_Processing_Support" />
  <id>/articles/Adding_Processing_Support</id>
  <published>2014-11-02T00:00:00+01:00</published>
  <updated>2014-11-02T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;h4 id=&quot;added-support-for-realtimeplotter-and-arduplot&quot;&gt;2014-11-02: Added support for RealtimePlotter and arduplot&lt;/h4&gt;
&lt;p&gt;I learned, that the main part on building a sensor is the software to grind and polish the
signals read from the hardware sensor. In this case it was the Allegro ACS758LCB-100U hall 
effect current sensor.&lt;/p&gt;

&lt;p&gt;So I read about digital filtering and use 3 cascaded the &lt;code&gt;Moving Average&lt;/code&gt; algorithm to smooth the
sensor reading.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; //filter use in main.c
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; AddToFloatAvg(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;cur_filter1, (cur_mea_val));
&lt;span class=&quot;lineno&quot;&gt;3&lt;/span&gt; AddToFloatAvg(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;cur_filter2, GetOutputValue(&lt;span class=&quot;ni&quot;&gt;&amp;amp;cur_filter1));&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;4&lt;/span&gt; AddToFloatAvg(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;cur_filter3, GetOutputValue(&lt;span class=&quot;ni&quot;&gt;&amp;amp;cur_filter2));&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;5&lt;/span&gt; cur_adc_res[act] = (GetOutputValue(&lt;span class=&quot;ni&quot;&gt;&amp;amp;cur_filter3));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Each filter has 9 readings. For details see &lt;code&gt;src/floating_average.h&lt;/code&gt; and &lt;code&gt;.c&lt;/code&gt; files.&lt;/p&gt;

&lt;p&gt;By testing I used the DX9 transmitter, recorded to the SD card and read that using the TLM Reader.
This was a long procedure. Since I already put a header with the Rx, Tx serial pins on the
board it shouldn’t be that much of a problem to show some output on the Mac using the Processing
tools.&lt;/p&gt;

&lt;p&gt;I found two great serial monitors based on &lt;a href=&quot;https://www.processing.org/&quot;&gt;Processing&lt;/a&gt;.
Please see the &lt;a href=&quot;https://github.com/sebnil/RealtimePlotter.git&quot;&gt;RealtimePlotter&lt;/a&gt; and 
&lt;a href=&quot;https://github.com/dahart/arduplot.git&quot;&gt;Arduplot&lt;/a&gt;. Thanks to their contributors. Just uncomment
the lines in the &lt;code&gt;config/conf_board.h&lt;/code&gt; file.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/articles/Adding_Processing_Support&quot;&gt;Adding Processing support&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on November 02, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[First test flight]]></title>
  <link rel="alternate" type="text/html" href="/articles/test-flight-log" />
  <id>/articles/test-flight-log</id>
  <published>2014-10-29T00:00:00+01:00</published>
  <updated>2014-10-29T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;This was one of the first flights using the sensor in it’s target environment, the T-REX 500 RC
heli. I did a lot of bench testing using a light bulb up to 3A. But nor the bulb or the power
supply could have done much more. So this was the first test with more Amps.&lt;/p&gt;

&lt;p&gt;I’m using a Spektrum DX9 transmitter with SD card slot. I use the TLM Reader. Here is the result:&lt;/p&gt;

&lt;figure&gt;
	&lt;img src=&quot;/images/TREX500_20141026_REVA.png&quot; /&gt;
	&lt;figcaption&gt;T-REX 500 flight log&lt;/figcaption&gt;
&lt;/figure&gt;

  &lt;p&gt;&lt;a href=&quot;/articles/test-flight-log&quot;&gt;First test flight&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on October 29, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Initial Upload]]></title>
  <link rel="alternate" type="text/html" href="/Initial%20upload" />
  <id>/Initial upload</id>
  <published>2014-10-28T00:00:00+01:00</published>
  <updated>2014-10-28T00:00:00+01:00</updated>
  <author>
    <name>Christian</name>
    <uri></uri>
    <email>git@cescholz.de</email>
  </author>
  <content type="html">&lt;p&gt;The prototype of the spektel-sensor passed its first successful tests. The revision A layout
and corresponding code is up on &lt;a href=&quot;https://github.com/csc13/spektel-sensor.git&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please be aware, that &lt;code&gt;REV_A&lt;/code&gt; had several faults on the board. So the Bosch BMP180 sensor
won’t work, because I didn’t read the datasheet correctly.&lt;/p&gt;

&lt;p&gt;After learning Eagle PCB, a software I can recommend to everybody, I spend some nights to
find the Eagle libraries for the parts I wanted to use and create the layout. At the end
I was little impatient to order the PCB (printed circuite board) at a board manufacturer.
I chose a little one, who did a great job etching and drilling the board.&lt;/p&gt;

&lt;p&gt;But I found several bugs in the layout. So I used a exacto hobby knife, some lacquered copper
wire and fixed it. As a mostly software guy I had to learn that a hardware bug can’t be fixed that
fast. And ordering a new board takes some days and money. so in the future I will print the board
layout on paper and go through all components and wires.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;/Initial%20upload&quot;&gt;Initial Upload&lt;/a&gt; was originally published by Christian at &lt;a href=&quot;&quot;&gt;spektel-sensor&lt;/a&gt; on October 28, 2014.&lt;/p&gt;</content>
</entry>

</feed>